<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Airsoft Tactical Pro</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #000; color: #00ff00; overflow: hidden; }
        
        .setup-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            z-index: 10000;
        }
        
        .setup-box {
            background: #1a1a1a; padding: 30px; border-radius: 15px;
            border: 2px solid #00ff00; text-align: center; max-width: 90%;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }
        
        .setup-box h1 { margin-bottom: 20px; font-size: 24px; }
        .setup-box input {
            width: 100%; padding: 12px; margin: 10px 0;
            background: #333; border: 2px solid #00ff00; color: #00ff00;
            border-radius: 8px; font-size: 16px;
        }
        
        .setup-box button {
            padding: 15px 30px; background: #00ff00; color: #000;
            border: none; border-radius: 8px; cursor: pointer;
            font-weight: bold; font-size: 16px; margin-top: 15px;
        }
        
        #map { width: 100%; height: 100vh; }
        
        .hud {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1000;
        }
        
        .status {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.8); padding: 8px; border-radius: 6px;
            border: 1px solid #00ff00; pointer-events: auto; font-size: 10px;
            display: flex; gap: 10px;
        }
        
        .layers {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.8); border: 1px solid #00ff00;
            border-radius: 6px; padding: 5px; pointer-events: auto;
            display: flex; gap: 5px;
        }
        
        .layer-btn {
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.8); border: 1px solid #00ff00;
            color: #00ff00; border-radius: 4px; cursor: pointer; font-size: 10px;
        }
        
        .layer-btn.active { background: rgba(0, 255, 0, 0.3); }
        
        .controls-bottom {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; pointer-events: auto;
            background: rgba(0, 0, 0, 0.8); padding: 8px; border-radius: 20px;
            border: 1px solid #00ff00;
        }
        
        .zoom-controls {
            position: absolute; bottom: 70px; right: 10px;
            display: flex; flex-direction: column; gap: 5px;
            pointer-events: auto;
        }
        
        .zoom-btn {
            width: 35px; height: 35px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff00;
            color: #00ff00;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-btn:hover { 
            background: rgba(0, 255, 0, 0.2); 
        }
        
        .zoom-btn:active {
            background: rgba(0, 255, 0, 0.4);
        }
        
        .btn {
            padding: 8px 12px; background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff00; color: #00ff00; border-radius: 15px;
            cursor: pointer; font-weight: bold; font-size: 10px;
        }
        
        .btn:hover { background: rgba(0, 255, 0, 0.2); }
        .btn.active { background: rgba(255, 0, 0, 0.8); border-color: #ff0000; color: #fff; }
        
        .draw-panel {
            position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9); border: 1px solid #00ff00;
            border-radius: 15px; padding: 8px; pointer-events: auto;
            display: none;
        }
        
        .draw-panel.show { display: flex; gap: 5px; align-items: center; }
        
        .obstacle-text-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 20px;
            z-index: 10000;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.7);
        }
        
        .obstacle-text-popup h3 {
            color: #00ff00;
            margin: 0 0 15px 0;
        }
        
        .obstacle-text-popup input {
            width: 200px;
            padding: 8px;
            margin: 10px 0;
            background: #333;
            border: 1px solid #00ff00;
            color: #00ff00;
            border-radius: 5px;
        }
        
        .obstacle-text-popup button {
            padding: 8px 15px;
            margin: 0 5px;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .obstacle-text-popup button.cancel {
            background: #ff4444;
            color: white;
        }
        
        .obstacle-text-popup button:hover {
            opacity: 0.8;
        }
        
        .color-picker { display: flex; gap: 4px; margin: 0 5px; }
        .color { 
            width: 14px; height: 14px; border-radius: 50%;
            border: 1px solid #fff; cursor: pointer;
        }
        .color.active { border-color: #00ff00; box-shadow: 0 0 8px currentColor; }
        
        .hidden { display: none !important; }
        
        .loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9); padding: 20px; border-radius: 8px;
            border: 2px solid #00ff00; z-index: 9999; text-align: center;
        }
        
        .notification {
            position: fixed; top: 60px; right: 10px; z-index: 2000;
            background: rgba(0, 255, 0, 0.9); color: #000; padding: 8px 15px;
            border-radius: 15px; font-weight: bold; font-size: 11px;
            animation: slideIn 0.3s ease;
        }
        
        .qr-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); display: none; justify-content: center; align-items: center;
            z-index: 15000;
        }
        
        .qr-content {
            background: #1a1a1a; padding: 30px; border-radius: 15px;
            border: 2px solid #00ff00; text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
            max-width: 90%; width: 350px;
        }
        
        .qr-content h3 { color: #00ff00; margin-bottom: 15px; }
        
        .qr-code-container {
            background: white; padding: 20px; border-radius: 10px;
            margin: 20px 0; display: inline-block;
        }
        
        .team-code {
            background: rgba(0, 255, 0, 0.2); padding: 10px;
            border-radius: 8px; margin: 15px 0;
            font-size: 18px; font-weight: bold; letter-spacing: 2px;
        }
        
        .qr-content button {
            padding: 10px 20px; background: #00ff00; color: #000;
            border: none; border-radius: 8px; cursor: pointer;
            font-weight: bold; margin: 5px;
        }
        
        .close-btn { background: #ff4444 !important; color: white !important; }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes enemyPulse { 
            0%, 100% { opacity: 1; transform: scale(1); } 
            50% { opacity: 0.6; transform: scale(1.2); } 
        }
        
        .enemy-marker-icon {
            width: 30px; height: 30px;
            background: radial-gradient(circle, #ff0000, #cc0000);
            border: 3px solid #ffff00;
            border-radius: 50%;
            box-shadow: 0 0 20px #ff0000;
            animation: enemyPulse 1s infinite;
        }
        
        .obstacle-text-icon {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            width: 100% !important;
            height: 100% !important;
        }
        
        .obstacle-text-icon > div {
            display: inline-block !important;
        }
        
        .leaflet-div-icon-text {
            background: none !important;
            border: none !important;
            text-align: center !important;
        }
        
        .leaflet-div-icon-text > div {
            display: inline-block !important;
            position: relative !important;
        }
        
        .text-label-marker {
            background: none !important;
            border: none !important;
        }
        
        .text-label-marker span {
            position: absolute !important;
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) !important;
        }
        
        .obstacle-label-div {
            background: transparent !important;
            border: none !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
        }
        
        .obstacle-label-div > div {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
        }
        
        .obstacle-label-div > div > div {
            display: inline-block !important;
        }
        
        .obstacle-text-tooltip {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            z-index: 500 !important;  /* Sous les ennemis */
        }
        
        .obstacle-text-tooltip div {
            text-shadow: 2px 2px 4px rgba(0,0,0,1);
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
        }
        
        /* S'assurer que les marqueurs ennemis sont toujours au-dessus */
        .leaflet-pane.leaflet-enemyPane {
            z-index: 650 !important;
        }
        
        .leaflet-tooltip-pane {
            z-index: 600 !important;
        }
        
        .leaflet-overlay-pane {
            z-index: 400 !important;
        }
        
        /* Style pour les obstacles en mode édition */
        .obstacle-editable {
            cursor: pointer !important;
        }
        
        .obstacle-popup {
            z-index: 700 !important;
        }
    </style>
</head>
<body>
    <div class="setup-screen" id="setupScreen">
        <div class="setup-box">
            <h1>🎯 AIRSOFT TACTICAL</h1>
            <input type="text" id="teamCode" placeholder="Code équipe (ex: ALPHA)" maxlength="15">
            <input type="text" id="playerName" placeholder="Votre indicatif (ex: LEADER)" maxlength="10">
            <button onclick="App.start()">🚀 DÉMARRER MISSION</button>
        </div>
    </div>

    <div class="loading hidden" id="loadingScreen">
        <div>📡 Connexion...</div>
        <div id="loadingStatus" style="font-size: 12px; margin-top: 10px;">Initialisation</div>
    </div>

    <div id="map" class="hidden"></div>

    <div class="hud hidden" id="gameHUD">
        <div class="status">
            <div id="firebaseStatus">🔥OFF</div>
            <div id="gpsStatus">📍OFF</div>
            <div id="teamStatus">👥0</div>
        </div>

        <div class="layers">
            <button class="layer-btn active" onclick="App.switchLayer('standard')">Standard</button>
            <button class="layer-btn" onclick="App.switchLayer('satellite')">Satellite</button>
            <button class="layer-btn" onclick="App.switchLayer('tactical')">Tactique</button>
        </div>

        <div class="zoom-controls">
            <button class="zoom-btn" onclick="App.zoomIn()">+</button>
            <button class="zoom-btn" onclick="App.zoomOut()">−</button>
        </div>

        <div class="controls-bottom">
            <button class="btn" onclick="App.centerPlayer()">📍</button>
            <button class="btn" onclick="App.recalibrateGPS()">🔄</button>
            <button class="btn" id="enemyBtn" onclick="App.toggleEnemyMode()">🎯</button>
            <button class="btn" id="drawBtn" onclick="App.toggleDrawMode()">✏️</button>
            <button class="btn" id="editBtn" onclick="App.toggleEditMode()">🗑️</button>
            <button class="btn" id="sensorBtn" onclick="App.toggleSensorMode()">📡</button>
            <button class="btn" onclick="App.showQRCode()">📲</button>
        </div>

        <div class="draw-panel" id="drawPanel">
            <button class="btn active" onclick="App.setDrawTool('rectangle')">▭</button>
            <button class="btn" onclick="App.setDrawTool('circle')">○</button>
            <button class="btn" onclick="App.setDrawTool('polygon')">⬟</button>
            <button class="btn" onclick="App.setDrawTool('line')">╱</button>
            <div class="color-picker">
                <div class="color active" style="background: #ff4444;" onclick="App.setDrawColor('#ff4444', event)"></div>
                <div class="color" style="background: #ffaa00;" onclick="App.setDrawColor('#ffaa00', event)"></div>
                <div class="color" style="background: #00ff00;" onclick="App.setDrawColor('#00ff00', event)"></div>
                <div class="color" style="background: #0080ff;" onclick="App.setDrawColor('#0080ff', event)"></div>
            </div>
        </div>
    </div>

    <div class="qr-modal" id="qrModal">
        <div class="qr-content">
            <h3>📡 PARTAGER L'ÉQUIPE</h3>
            <div class="team-code">CODE: <span id="qrTeamCode"></span></div>
            <div class="qr-code-container">
                <img id="qrcode" alt="QR Code" style="width: 200px; height: 200px;">
            </div>
            <button onclick="App.copyTeamLink()">📋 Copier le lien</button>
            <button id="installBtn" onclick="App.installPWA()" style="display: none;">📥 Installer l'app</button>
            <button class="close-btn" onclick="App.closeModal()">Fermer</button>
            <div style="margin-top: 15px;">
                <a href="#" onclick="App.changeTeam()" style="color: #888; font-size: 11px; text-decoration: underline;">Changer d'équipe</a>
            </div>
        </div>
    </div>

    <div class="sensor-panel" id="sensorPanel">
        <h3 style="color: #00ff00; margin: 0 0 10px 0; font-size: 14px;">📡 CAPTEURS</h3>
        <div id="sensorList"></div>
        <button class="btn" onclick="App.addNewSensor()" style="width: 100%; margin-top: 10px;">
            ➕ Ajouter capteur
        </button>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue, remove, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Application principale
        const App = {
            // État global
            map: null,
            layers: {},
            markers: {
                player: null,
                teammates: {},
                enemies: {}
            },
            groups: {
                obstacles: null,
                grid: null
            },
            firebase: {
                app: null,
                db: null,
                refs: {}
            },
            state: {
                teamCode: null,
                playerName: null,
                position: null,
                watchId: null,
                isConnected: false,
                enemyMode: false,
                drawMode: false,
                editMode: false,        // Mode édition pour supprimer
                sensorMode: false,      // Mode capteurs
                drawTool: 'rectangle',
                drawColor: '#ff4444',
                isDrawing: false,
                drawStart: null,
                preview: null,
                deferredPrompt: null,  // Pour l'installation PWA
                polygonPoints: [],     // Points du polygone en cours
                linePoints: [],        // Points de la ligne en cours
                tempMarkers: [],       // Marqueurs temporaires pour les points
                sensors: {}           // État des capteurs
            },

            // Configuration Firebase - REMPLACEZ PAR LA VÔTRE !
            firebaseConfig: {
                // COPIEZ ICI VOTRE CONFIGURATION FIREBASE
                // Elle ressemble à ça :
                apiKey: "OninF0hGCgA3fJ600rPOWgo8qrBr222ijsprPfWT",
                authDomain: "airsoft-tactical.firebaseapp.com",
                databaseURL: "https://airsoft-tactical-default-rtdb.europe-west1.firebasedatabase.app",
                projectId: "airsoft-tactical",
                storageBucket: "airsoft-tactical.appspot.com",
                messagingSenderId: "Admin01",
                appId: "001"
            },

            // Initialisation
            async start() {
                const teamCode = document.getElementById('teamCode').value.trim().toUpperCase();
                const playerName = document.getElementById('playerName').value.trim().toUpperCase();

                if (!teamCode || !playerName) {
                    alert('Remplissez tous les champs');
                    return;
                }

                this.state.teamCode = teamCode;
                this.state.playerName = playerName;
                
                localStorage.setItem('airsoftConfig', JSON.stringify({teamCode, playerName}));

                document.getElementById('setupScreen').classList.add('hidden');
                document.getElementById('loadingScreen').classList.remove('hidden');

                await this.initFirebase();
                this.initMap();
                this.initGPS();
            },

            async initFirebase() {
                this.updateLoading('Connexion Firebase...');
                
                try {
                    this.firebase.app = initializeApp(this.firebaseConfig);
                    this.firebase.db = getDatabase(this.firebase.app);
                    
                    // Vérifier connexion
                    const connRef = ref(this.firebase.db, '.info/connected');
                    onValue(connRef, (snap) => {
                        this.state.isConnected = snap.val() === true;
                        this.updateStatus('firebaseStatus', this.state.isConnected ? '🔥ON' : '🔥OFF');
                        
                        if (this.state.isConnected) {
                            this.setupFirebaseListeners();
                        }
                    });

                    // Timeout pour éviter blocage
                    setTimeout(() => {
                        if (!this.state.isConnected) {
                            console.warn('Firebase timeout - mode offline');
                            this.showMap();
                        }
                    }, 5000);

                } catch (error) {
                    console.error('Erreur Firebase:', error);
                    this.state.isConnected = false;
                }
            },

            setupFirebaseListeners() {
                if (!this.firebase.db || !this.state.teamCode) return;

                const team = this.state.teamCode;
                console.log('Configuration Firebase pour équipe:', team);
                
                // Références
                this.firebase.refs.team = ref(this.firebase.db, `teams/${team}`);
                this.firebase.refs.obstacles = ref(this.firebase.db, `obstacles/${team}`);
                this.firebase.refs.enemies = ref(this.firebase.db, `enemies/${team}`);
                this.firebase.refs.sensors = ref(this.firebase.db, `sensors/${team}`);
                
                // Écoute des changements
                onValue(this.firebase.refs.team, (snap) => this.updateTeammates(snap.val()));
                
                // Écoute des capteurs
                onValue(this.firebase.refs.sensors, (snap) => {
                    console.log('=== MISE À JOUR CAPTEURS ===');
                    console.log('Données reçues:', snap.val());
                    this.updateSensors(snap.val());
                });
                
                // Écoute des changements
                onValue(this.firebase.refs.team, (snap) => this.updateTeammates(snap.val()));
                
                // IMPORTANT: S'assurer que les ennemis sont bien écoutés
                onValue(this.firebase.refs.enemies, (snap) => {
                    console.log('=== MISE À JOUR ENNEMIS FIREBASE ===');
                    console.log('Données reçues:', snap.val());
                    this.updateEnemies(snap.val());
                });
                
                // IMPORTANT: Forcer le chargement initial des obstacles
                onValue(this.firebase.refs.obstacles, (snap) => {
                    console.log('Obstacles Firebase:', snap.val());
                    this.updateObstacles(snap.val());
                });
                
                // Nettoyer les vieux ennemis au démarrage
                onValue(this.firebase.refs.enemies, (snap) => {
                    const enemies = snap.val();
                    if (enemies) {
                        Object.keys(enemies).forEach(id => {
                            const enemy = enemies[id];
                            if (enemy.expiresAt && Date.now() > enemy.expiresAt) {
                                console.log('Nettoyage vieil ennemi:', id);
                                const enemyRef = ref(this.firebase.db, `enemies/${team}/${id}`);
                                remove(enemyRef);
                            }
                        });
                    }
                }, { onlyOnce: true });
                
                // Forcer un rafraîchissement après 1 seconde
                setTimeout(() => {
                    console.log('Vérification manuelle des données');
                    
                    // Vérifier les ennemis
                    onValue(this.firebase.refs.enemies, (snap) => {
                        const enemies = snap.val();
                        console.log('Ennemis actuels dans Firebase:', enemies);
                        if (enemies) {
                            console.log('Nombre d\'ennemis:', Object.keys(enemies).length);
                        }
                    }, { onlyOnce: true });
                    
                    // Vérifier les obstacles
                    onValue(this.firebase.refs.obstacles, (snap) => {
                        this.updateObstacles(snap.val());
                    }, { onlyOnce: true });
                    
                    // IMPORTANT: Vérifier aussi les capteurs
                    if (this.firebase.refs.sensors) {
                        console.log('Vérification des capteurs...');
                        onValue(this.firebase.refs.sensors, (snap) => {
                            const sensors = snap.val();
                            console.log('Capteurs trouvés dans Firebase:', sensors);
                            this.updateSensors(sensors);
                        }, { onlyOnce: true });
                    }
                }, 1000);
                
                // Déconnexion auto
                const playerRef = ref(this.firebase.db, `teams/${team}/${this.state.playerName}`);
                onDisconnect(playerRef).remove();
            },

            initMap() {
                this.updateLoading('Chargement carte...');
                
                this.map = L.map('map', {
                    center: [48.8566, 2.3522],
                    zoom: 15,
                    maxZoom: 21,
                    zoomControl: false,
                    attributionControl: false
                });

                // Créer un pane personnalisé pour les ennemis (au-dessus de tout)
                this.map.createPane('enemyPane');
                this.map.getPane('enemyPane').style.zIndex = 650; // Au-dessus des tooltips (600)

                // Couches de carte avec zoom étendu
                this.layers.standard = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 21,
                    maxNativeZoom: 19
                });

                this.layers.satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    maxZoom: 21,
                    maxNativeZoom: 19
                });

                this.layers.tactical = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                    maxZoom: 21,
                    maxNativeZoom: 19
                });

                // Ajout couche par défaut
                this.layers.standard.addTo(this.map);

                // IMPORTANT: Créer et ajouter les groupes à la carte immédiatement
                console.log('Création des groupes de couches');
                this.groups.obstacles = L.layerGroup();
                this.groups.obstacles.addTo(this.map);
                console.log('Groupe obstacles ajouté à la carte');
                
                this.groups.grid = L.layerGroup();

                // Événements carte
                this.map.on('click', (e) => this.onMapClick(e));
                this.map.on('mousemove', (e) => this.onMapMove(e));
                this.map.on('contextmenu', (e) => this.onMapRightClick(e));
                this.map.on('dblclick', (e) => this.onMapDoubleClick(e));
                
                // Forcer le chargement des obstacles existants après init complète
                setTimeout(() => {
                    if (this.firebase.refs.obstacles) {
                        console.log('Vérification manuelle des obstacles');
                        onValue(this.firebase.refs.obstacles, (snap) => {
                            console.log('Obstacles trouvés:', snap.val());
                            this.updateObstacles(snap.val());
                        }, { onlyOnce: true });
                    }
                }, 2000);
            },

            initGPS() {
                if (!navigator.geolocation) {
                    this.notify('GPS non disponible');
                    this.showMap();
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    (pos) => this.onGPSSuccess(pos),
                    (err) => this.onGPSError(err),
                    { enableHighAccuracy: true, maximumAge: 0, timeout: 30000 }
                );

                this.state.watchId = navigator.geolocation.watchPosition(
                    (pos) => this.onGPSSuccess(pos),
                    (err) => this.onGPSError(err),
                    { enableHighAccuracy: true, maximumAge: 3000, timeout: 20000 }
                );
            },

            onGPSSuccess(position) {
                const accuracy = position.coords.accuracy;
                
                if (accuracy > 500) {
                    this.updateStatus('gpsStatus', `📍${Math.round(accuracy)}m`);
                    return;
                }

                this.state.position = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    accuracy: Math.round(accuracy)
                };

                this.updateStatus('gpsStatus', accuracy < 50 ? '📍OK' : `📍${Math.round(accuracy)}m`);
                this.updatePlayerMarker();
                this.sharePosition();
                
                // Mettre à jour les distances des ennemis
                this.updateEnemyDistances();

                if (document.getElementById('map').classList.contains('hidden')) {
                    this.showMap();
                }
            },

            onGPSError(error) {
                console.error('GPS Error:', error);
                this.updateStatus('gpsStatus', '📍ERR');
                
                // Position démo
                this.state.position = {
                    lat: 48.8566 + (Math.random() - 0.5) * 0.01,
                    lng: 2.3522 + (Math.random() - 0.5) * 0.01,
                    accuracy: 999
                };
                
                this.updatePlayerMarker();
                this.showMap();
            },

            showMap() {
                document.getElementById('loadingScreen').classList.add('hidden');
                document.getElementById('map').classList.remove('hidden');
                document.getElementById('gameHUD').classList.remove('hidden');
                
                if (this.map) {
                    this.map.invalidateSize();
                    if (this.state.position) {
                        this.map.setView([this.state.position.lat, this.state.position.lng], 17);
                    }
                }
            },

            updatePlayerMarker() {
                if (!this.map || !this.state.position) return;

                if (this.markers.player) {
                    this.map.removeLayer(this.markers.player);
                }

                const icon = L.divIcon({
                    className: '',
                    html: `<div style="width: 20px; height: 20px; background: #0080ff; border: 3px solid #fff; border-radius: 50%; box-shadow: 0 0 15px #0080ff;"></div>`,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });

                this.markers.player = L.marker([this.state.position.lat, this.state.position.lng], {
                    icon,
                    zIndexOffset: 1000
                }).addTo(this.map);
            },

            sharePosition() {
                if (!this.state.isConnected || !this.state.position) return;

                const playerRef = ref(this.firebase.db, `teams/${this.state.teamCode}/${this.state.playerName}`);
                set(playerRef, {
                    lat: this.state.position.lat,
                    lng: this.state.position.lng,
                    accuracy: this.state.position.accuracy,
                    timestamp: Date.now()
                });
            },

            updateTeammates(data) {
                if (!data) return;
                
                const count = Object.keys(data).length;
                this.updateStatus('teamStatus', `👥${count}`);

                Object.keys(data).forEach(name => {
                    if (name === this.state.playerName) return;

                    const member = data[name];
                    
                    if (this.markers.teammates[name]) {
                        this.map.removeLayer(this.markers.teammates[name]);
                    }

                    const icon = L.divIcon({
                        className: '',
                        html: `<div style="display: flex; flex-direction: column; align-items: center;">
                            <div style="width: 16px; height: 16px; background: #00ff00; border: 2px solid #fff; border-radius: 50%;"></div>
                            <div style="background: rgba(0,0,0,0.7); color: #00ff00; padding: 2px 4px; border-radius: 8px; font-size: 9px; font-weight: bold; margin-top: 2px;">${name}</div>
                        </div>`,
                        iconSize: [50, 30],
                        iconAnchor: [25, 15]
                    });

                    this.markers.teammates[name] = L.marker([member.lat, member.lng], {icon}).addTo(this.map);
                });
            },

            updateObstacles(data) {
                console.log('=== UPDATE OBSTACLES ===', data);
                
                // S'assurer que le groupe obstacles existe et est sur la carte
                if (!this.groups.obstacles) {
                    console.log('Création du groupe obstacles');
                    this.groups.obstacles = L.layerGroup();
                }
                
                // S'assurer que le groupe est bien ajouté à la carte
                if (!this.map.hasLayer(this.groups.obstacles)) {
                    console.log('Ajout du groupe obstacles à la carte');
                    this.groups.obstacles.addTo(this.map);
                }
                
                // Effacer tous les obstacles existants
                this.groups.obstacles.clearLayers();
                
                if (!data) {
                    console.log('Aucun obstacle à afficher');
                    return;
                }

                let obstacleCount = 0;
                Object.keys(data).forEach(id => {
                    const obs = data[id];
                    let layer = null;

                    try {
                        if (obs.type === 'rectangle' && obs.bounds) {
                            console.log('Création rectangle:', id);
                            layer = L.rectangle([
                                [obs.bounds.south, obs.bounds.west],
                                [obs.bounds.north, obs.bounds.east]
                            ], {
                                color: obs.color || '#ff4444',
                                weight: 3,
                                fillOpacity: 0.3,
                                interactive: false,
                                bubblingMouseEvents: false  // Empêche la propagation des clics
                            });
                        } else if (obs.type === 'circle' && obs.center && obs.radius) {
                            console.log('Création cercle:', id);
                            layer = L.circle([obs.center.lat, obs.center.lng], {
                                radius: obs.radius,
                                color: obs.color || '#ff4444',
                                weight: 3,
                                fillOpacity: 0.3,
                                interactive: false,
                                bubblingMouseEvents: false
                            });
                        } else if (obs.type === 'polygon' && obs.points) {
                            console.log('Création polygone:', id);
                            const latlngs = obs.points.map(p => [p.lat, p.lng]);
                            layer = L.polygon(latlngs, {
                                color: obs.color || '#ff4444',
                                weight: 3,
                                fillOpacity: 0.3,
                                interactive: false,
                                bubblingMouseEvents: false
                            });
                        } else if (obs.type === 'line' && obs.points) {
                            console.log('Création ligne:', id);
                            const latlngs = obs.points.map(p => [p.lat, p.lng]);
                            layer = L.polyline(latlngs, {
                                color: obs.color || '#ff4444',
                                weight: 4,
                                interactive: false,
                                bubblingMouseEvents: false
                            });
                        }

                        if (layer) {
                            // IMPORTANT: Stocker les métadonnées AVANT d'ajouter au groupe
                            layer._obstacleId = id;
                            layer._obstacleData = obs;
                            
                            console.log('Layer créé avec ID:', layer._obstacleId, 'Data:', layer._obstacleData);
                            
                            // Ajouter le layer au groupe AVANT le tooltip
                            this.groups.obstacles.addLayer(layer);
                            
                            // Ajouter le texte si présent (APRÈS avoir ajouté le layer)
                            if (obs.text && obs.text.trim()) {
                                let center;
                                if (obs.type === 'circle') {
                                    center = [obs.center.lat, obs.center.lng];
                                } else if (obs.type === 'rectangle') {
                                    center = [(obs.bounds.south + obs.bounds.north) / 2, 
                                             (obs.bounds.west + obs.bounds.east) / 2];
                                } else if (obs.type === 'polygon' && obs.points.length > 0) {
                                    // Centroïde du polygone (méthode plus précise)
                                    let area = 0;
                                    let x = 0;
                                    let y = 0;
                                    const points = obs.points;
                                    const n = points.length;
                                    
                                    // Calcul du centroïde géométrique
                                    for (let i = 0; i < n; i++) {
                                        const j = (i + 1) % n;
                                        const xi = points[i].lng;
                                        const yi = points[i].lat;
                                        const xj = points[j].lng;
                                        const yj = points[j].lat;
                                        const a = xi * yj - xj * yi;
                                        area += a;
                                        x += (xi + xj) * a;
                                        y += (yi + yj) * a;
                                    }
                                    
                                    if (area !== 0) {
                                        area *= 3;
                                        center = [y / area, x / area];
                                    } else {
                                        // Fallback au centre moyen si l'aire est 0
                                        const sumLat = points.reduce((sum, p) => sum + p.lat, 0);
                                        const sumLng = points.reduce((sum, p) => sum + p.lng, 0);
                                        center = [sumLat / n, sumLng / n];
                                    }
                                } else if (obs.type === 'line' && obs.points.length >= 2) {
                                    // Milieu de la ligne
                                    const midIndex = Math.floor(obs.points.length / 2);
                                    center = [obs.points[midIndex].lat, obs.points[midIndex].lng];
                                }
                                
                                if (center) {
                                    const textContent = obs.text;
                                    const textColor = obs.color || '#ff4444';
                                    
                                    // Utiliser un tooltip permanent au lieu d'un marqueur
                                    const textTooltip = L.tooltip({
                                        permanent: true,
                                        direction: 'center',
                                        className: 'obstacle-text-tooltip',
                                        offset: [0, 0],
                                        interactive: false  // Non interactif pour ne pas bloquer les clics
                                    }).setContent(`<div style="
                                        background: rgba(0,0,0,0.9);
                                        color: ${textColor};
                                        padding: 8px 15px;
                                        border-radius: 8px;
                                        border: 2px solid ${textColor};
                                        font-weight: bold;
                                        font-size: 18px;
                                        text-align: center;
                                        white-space: nowrap;
                                        pointer-events: none;
                                        ">${textContent}</div>`);
                                    
                                    // Attacher le tooltip à la forme elle-même
                                    if (layer) {
                                        layer.bindTooltip(textTooltip);
                                    }
                                }
                            }
                            
                            obstacleCount++;
                        }
                    } catch (error) {
                        console.error('Erreur création obstacle:', error, obs);
                    }
                });
                
                console.log(`${obstacleCount} obstacles ajoutés au groupe`);
                
                // Forcer un rafraîchissement de la carte
                if (this.map) {
                    this.map.invalidateSize();
                }
            },
            
            removeObstacle(id) {
                console.log('Suppression obstacle demandée:', id);
                
                // Fermer le popup d'abord
                this.map.closePopup();
                
                // Supprimer de Firebase si connecté
                if (this.state.isConnected && this.firebase.db) {
                    const obsRef = ref(this.firebase.db, `obstacles/${this.state.teamCode}/${id}`);
                    remove(obsRef).then(() => {
                        console.log('Obstacle supprimé de Firebase');
                        this.notify('✅ Obstacle supprimé');
                        
                        // Recharger les obstacles pour mettre à jour l'affichage
                        if (this.firebase.refs.obstacles) {
                            onValue(this.firebase.refs.obstacles, (snap) => {
                                this.updateObstacles(snap.val());
                            }, { onlyOnce: true });
                        }
                    }).catch(err => {
                        console.error('Erreur suppression:', err);
                        this.notify('❌ Erreur suppression');
                    });
                } else {
                    // Suppression locale seulement
                    this.groups.obstacles.eachLayer(layer => {
                        if (layer._obstacleId === id) {
                            this.groups.obstacles.removeLayer(layer);
                        }
                    });
                    this.notify('✅ Obstacle supprimé (local)');
                }
            },

            updateEnemies(data) {
                console.log('=== UPDATE ENEMIES FROM FIREBASE ===');
                console.log('Team:', this.state.teamCode);
                console.log('Données brutes reçues:', data);
                
                // Supprimer les ennemis qui ne sont plus dans Firebase
                Object.keys(this.markers.enemies).forEach(id => {
                    if (!data || !data[id]) {
                        console.log('Suppression ennemi local:', id);
                        if (this.markers.enemies[id]) {
                            if (this.markers.enemies[id]._timeoutId) {
                                clearTimeout(this.markers.enemies[id]._timeoutId);
                            }
                            this.map.removeLayer(this.markers.enemies[id]);
                            delete this.markers.enemies[id];
                        }
                    }
                });

                if (!data) {
                    console.log('Aucun ennemi dans Firebase');
                    return;
                }

                // Parcourir tous les ennemis de Firebase
                Object.keys(data).forEach(id => {
                    const enemy = data[id];
                    console.log(`Traitement ennemi ${id}:`, enemy);

                    // Vérifier expiration
                    if (enemy.expiresAt && Date.now() > enemy.expiresAt) {
                        console.log('Ennemi expiré:', id);
                        const enemyRef = ref(this.firebase.db, `enemies/${this.state.teamCode}/${id}`);
                        remove(enemyRef);
                        return;
                    }

                    // Créer le marqueur s'il n'existe pas déjà
                    if (!this.markers.enemies[id]) {
                        // Valider les coordonnées
                        if (!enemy.lat || !enemy.lng) {
                            console.error('Coordonnées invalides pour ennemi:', id, enemy);
                            return;
                        }
                        
                        console.log(`Création nouveau marqueur ennemi ${id} de ${enemy.reportedBy}`);
                        
                        // Créer avec position fixe
                        this.createEnemyMarker(id, {
                            lat: parseFloat(enemy.lat),
                            lng: parseFloat(enemy.lng),
                            reportedBy: enemy.reportedBy || 'INCONNU',
                            expiresAt: enemy.expiresAt
                        });
                        
                        // Notification si c'est un autre joueur
                        if (enemy.reportedBy && enemy.reportedBy !== this.state.playerName) {
                            console.log('Notification pour ennemi de:', enemy.reportedBy);
                            this.notify(`⚠️ ${enemy.reportedBy} signale un ennemi!`);
                            if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
                        }
                    } else {
                        console.log('Ennemi déjà affiché:', id);
                    }
                });
                
                console.log('Ennemis actuels affichés:', Object.keys(this.markers.enemies));
            },

            toggleEnemyMode() {
                this.state.enemyMode = !this.state.enemyMode;
                const btn = document.getElementById('enemyBtn');
                
                if (this.state.enemyMode) {
                    // Désactiver les autres modes
                    if (this.state.drawMode) this.toggleDrawMode();
                    if (this.state.editMode) this.toggleEditMode();
                    
                    btn.classList.add('active');
                    this.map.getContainer().style.cursor = 'crosshair';
                    this.notify('🎯 Cliquez pour marquer un ennemi');
                } else {
                    btn.classList.remove('active');
                    this.map.getContainer().style.cursor = '';
                }
            },

            toggleDrawMode() {
                this.state.drawMode = !this.state.drawMode;
                const btn = document.getElementById('drawBtn');
                const panel = document.getElementById('drawPanel');
                
                if (this.state.drawMode) {
                    // Désactiver les autres modes
                    if (this.state.enemyMode) this.toggleEnemyMode();
                    if (this.state.editMode) this.toggleEditMode();
                    
                    btn.classList.add('active');
                    panel.classList.add('show');
                    this.map.getContainer().style.cursor = 'crosshair';
                    this.notify('✏️ Mode dessin - Cliquez pour dessiner');
                } else {
                    btn.classList.remove('active');
                    panel.classList.remove('show');
                    this.map.getContainer().style.cursor = '';
                    
                    // Nettoyer les points temporaires
                    this.clearTempMarkers();
                    this.state.polygonPoints = [];
                    this.state.linePoints = [];
                    if (this.state.preview) {
                        this.map.removeLayer(this.state.preview);
                        this.state.preview = null;
                    }
                }
            },
            
            toggleEditMode() {
                this.state.editMode = !this.state.editMode;
                const btn = document.getElementById('editBtn');
                
                if (this.state.editMode) {
                    // Désactiver les autres modes
                    if (this.state.enemyMode) this.toggleEnemyMode();
                    if (this.state.drawMode) this.toggleDrawMode();
                    
                    btn.classList.add('active');
                    this.map.getContainer().style.cursor = 'pointer';
                    
                    // Recharger les obstacles pour s'assurer qu'ils sont bien configurés
                    if (this.firebase.refs && this.firebase.refs.obstacles) {
                        onValue(this.firebase.refs.obstacles, (snap) => {
                            this.updateObstaclesForEdit(snap.val());
                        }, { onlyOnce: true });
                    } else {
                        // Mode hors ligne - activer directement
                        this.activateEditMode();
                    }
                    
                    this.notify('🗑️ Mode édition activé - Cliquez sur un obstacle');
                } else {
                    btn.classList.remove('active');
                    this.map.getContainer().style.cursor = '';
                    
                    // Recharger les obstacles en mode normal
                    if (this.firebase.refs && this.firebase.refs.obstacles) {
                        onValue(this.firebase.refs.obstacles, (snap) => {
                            this.updateObstacles(snap.val());
                        }, { onlyOnce: true });
                    }
                    
                    this.map.closePopup();
                }
            },
            
            updateObstaclesForEdit(data) {
                console.log('=== UPDATE OBSTACLES FOR EDIT ===');
                
                // Effacer et recréer pour s'assurer que tout est propre
                if (this.groups.obstacles) {
                    this.groups.obstacles.clearLayers();
                }
                
                if (!data) {
                    console.log('Aucun obstacle');
                    return;
                }
                
                Object.keys(data).forEach(id => {
                    const obs = data[id];
                    let layer = null;
                    
                    try {
                        if (obs.type === 'rectangle' && obs.bounds) {
                            layer = L.rectangle([
                                [obs.bounds.south, obs.bounds.west],
                                [obs.bounds.north, obs.bounds.east]
                            ], {
                                color: obs.color || '#ff4444',
                                weight: 4,
                                fillOpacity: 0.5,
                                interactive: true,
                                className: 'obstacle-editable'
                            });
                        } else if (obs.type === 'circle' && obs.center && obs.radius) {
                            layer = L.circle([obs.center.lat, obs.center.lng], {
                                radius: obs.radius,
                                color: obs.color || '#ff4444',
                                weight: 4,
                                fillOpacity: 0.5,
                                interactive: true,
                                className: 'obstacle-editable'
                            });
                        } else if (obs.type === 'polygon' && obs.points) {
                            const latlngs = obs.points.map(p => [p.lat, p.lng]);
                            layer = L.polygon(latlngs, {
                                color: obs.color || '#ff4444',
                                weight: 4,
                                fillOpacity: 0.5,
                                interactive: true,
                                className: 'obstacle-editable'
                            });
                        } else if (obs.type === 'line' && obs.points) {
                            const latlngs = obs.points.map(p => [p.lat, p.lng]);
                            layer = L.polyline(latlngs, {
                                color: obs.color || '#ff4444',
                                weight: 6,
                                interactive: true,
                                className: 'obstacle-editable'
                            });
                        }
                        
                        if (layer) {
                            // Stocker les données
                            layer._obstacleId = id;
                            layer._obstacleData = obs;
                            
                            // Ajouter le texte si présent
                            if (obs.text && obs.text.trim()) {
                                let center;
                                if (obs.type === 'circle') {
                                    center = [obs.center.lat, obs.center.lng];
                                } else if (obs.type === 'rectangle') {
                                    center = [(obs.bounds.south + obs.bounds.north) / 2, 
                                             (obs.bounds.west + obs.bounds.east) / 2];
                                } else if (obs.type === 'polygon' && obs.points.length > 0) {
                                    const sumLat = obs.points.reduce((sum, p) => sum + p.lat, 0);
                                    const sumLng = obs.points.reduce((sum, p) => sum + p.lng, 0);
                                    center = [sumLat / obs.points.length, sumLng / obs.points.length];
                                } else if (obs.type === 'line' && obs.points.length >= 2) {
                                    const midIndex = Math.floor(obs.points.length / 2);
                                    center = [obs.points[midIndex].lat, obs.points[midIndex].lng];
                                }
                                
                                if (center) {
                                    const textTooltip = L.tooltip({
                                        permanent: true,
                                        direction: 'center',
                                        className: 'obstacle-text-tooltip',
                                        offset: [0, 0],
                                        interactive: false
                                    }).setContent(`<div style="
                                        background: rgba(0,0,0,0.9);
                                        color: ${obs.color || '#ff4444'};
                                        padding: 8px 15px;
                                        border-radius: 8px;
                                        border: 2px solid ${obs.color || '#ff4444'};
                                        font-weight: bold;
                                        font-size: 18px;
                                        text-align: center;
                                        white-space: nowrap;
                                        pointer-events: none;
                                        ">${obs.text}</div>`);
                                    
                                    layer.bindTooltip(textTooltip);
                                }
                            }
                            
                            // Ajouter hover effect
                            layer.on('mouseover', function() {
                                this.setStyle({
                                    fillOpacity: 0.7,
                                    weight: 6
                                });
                            });
                            
                            layer.on('mouseout', function() {
                                this.setStyle({
                                    fillOpacity: 0.5,
                                    weight: 4
                                });
                            });
                            
                            // Clic direct pour supprimer
                            layer.on('click', (e) => {
                                L.DomEvent.stopPropagation(e);
                                this.showDeletePopup(id, obs, e.latlng);
                            });
                            
                            this.groups.obstacles.addLayer(layer);
                        }
                    } catch (error) {
                        console.error('Erreur création obstacle edit:', error);
                    }
                });
            },
            
            toggleSensorMode() {
                this.state.sensorMode = !this.state.sensorMode;
                const btn = document.getElementById('sensorBtn');
                const panel = document.getElementById('sensorPanel');
                
                if (this.state.sensorMode) {
                    // Désactiver les autres modes
                    if (this.state.enemyMode) this.toggleEnemyMode();
                    if (this.state.drawMode) this.toggleDrawMode();
                    if (this.state.editMode) this.toggleEditMode();
                    
                    btn.classList.add('active');
                    panel.classList.add('show');
                    this.map.getContainer().style.cursor = 'crosshair';
                    
                    this.notify('📡 Mode capteurs - Cliquez pour placer');
                } else {
                    btn.classList.remove('active');
                    panel.classList.remove('show');
                    this.map.getContainer().style.cursor = '';
                }
            },
            
            updateSensors(data) {
                console.log('Mise à jour capteurs:', data);
                
                // Nettoyer les anciens marqueurs
                Object.keys(this.state.sensors).forEach(id => {
                    if (!data || !data[id]) {
                        if (this.state.sensors[id].marker) {
                            this.map.removeLayer(this.state.sensors[id].marker);
                        }
                        delete this.state.sensors[id];
                    }
                });
                
                if (!data) return;
                
                // Mettre à jour ou créer les marqueurs
                Object.keys(data).forEach(id => {
                    const sensor = data[id];
                    
                    // Créer ou mettre à jour le marqueur
                    if (!this.state.sensors[id]) {
                        this.state.sensors[id] = { data: sensor };
                        this.createSensorMarker(id, sensor);
                    } else {
                        // Mettre à jour l'état
                        this.state.sensors[id].data = sensor;
                        this.updateSensorMarker(id, sensor);
                    }
                });
                
                // Mettre à jour la liste dans le panneau
                this.updateSensorPanel();
            },
            
            createSensorMarker(id, sensor) {
                if (!sensor.position) return;
                
                const isTriggered = sensor.status === 'triggered' && 
                                  Date.now() - sensor.timestamp < 30000; // 30 sec
                
                const icon = L.divIcon({
                    className: 'sensor-marker-div',
                    html: `<div class="sensor-marker ${isTriggered ? 'triggered' : ''}">
                               📡
                           </div>
                           <div style="background: rgba(0,0,0,0.8); color: #00ff00; 
                                       padding: 2px 6px; border-radius: 4px; 
                                       font-size: 10px; margin-top: 2px;">
                               ${sensor.name || id}
                           </div>`,
                    iconSize: [30, 40],
                    iconAnchor: [15, 20]
                });
                
                const marker = L.marker([sensor.position.lat, sensor.position.lng], {
                    icon,
                    draggable: false
                }).addTo(this.map);
                
                // Popup de contrôle
                marker.bindPopup(`
                    <div style="text-align: center;">
                        <b>Capteur: ${sensor.name || id}</b><br>
                        <small>Type: ${sensor.type || 'IR'}</small><br>
                        <small>État: ${sensor.status || 'actif'}</small><br>
                        <div style="margin-top: 10px;">
                            <button onclick="App.triggerSensor('${id}')" 
                                style="background: #00ff00; color: #000; 
                                       border: none; padding: 5px 10px; 
                                       border-radius: 3px; cursor: pointer; 
                                       margin: 2px;">
                                🔔 Tester
                            </button>
                            <button onclick="App.removeSensor('${id}')" 
                                style="background: #ff4444; color: white; 
                                       border: none; padding: 5px 10px; 
                                       border-radius: 3px; cursor: pointer; 
                                       margin: 2px;">
                                ❌ Retirer
                            </button>
                        </div>
                    </div>
                `);
                
                this.state.sensors[id].marker = marker;
            },
            
            updateSensorMarker(id, sensor) {
                const marker = this.state.sensors[id].marker;
                if (!marker) return;
                
                const isTriggered = sensor.status === 'triggered' && 
                                  Date.now() - sensor.timestamp < 30000;
                
                // Mettre à jour l'icône
                const icon = L.divIcon({
                    className: 'sensor-marker-div',
                    html: `<div class="sensor-marker ${isTriggered ? 'triggered' : ''}">
                               📡
                           </div>
                           <div style="background: rgba(0,0,0,0.8); color: #00ff00; 
                                       padding: 2px 6px; border-radius: 4px; 
                                       font-size: 10px; margin-top: 2px;">
                               ${sensor.name || id}
                           </div>`,
                    iconSize: [30, 40],
                    iconAnchor: [15, 20]
                });
                
                marker.setIcon(icon);
                
                // Alerte si déclenché
                if (isTriggered && !this.state.sensors[id].alerted) {
                    this.state.sensors[id].alerted = true;
                    this.notify(`⚠️ Capteur ${sensor.name || id} déclenché!`);
                    if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
                    
                    // Reset alerte après 30 sec
                    setTimeout(() => {
                        this.state.sensors[id].alerted = false;
                    }, 30000);
                }
            },
            
            updateSensorPanel() {
                const list = document.getElementById('sensorList');
                if (!list) return;
                
                list.innerHTML = '';
                
                Object.keys(this.state.sensors).forEach(id => {
                    const sensor = this.state.sensors[id].data;
                    const isTriggered = sensor.status === 'triggered' && 
                                      Date.now() - sensor.timestamp < 30000;
                    
                    const item = document.createElement('div');
                    item.className = `sensor-item ${isTriggered ? 'triggered' : ''}`;
                    item.innerHTML = `
                        <span>${sensor.name || id}</span>
                        <span>${isTriggered ? '🚨' : '✅'}</span>
                    `;
                    
                    item.onclick = () => {
                        const marker = this.state.sensors[id].marker;
                        if (marker) {
                            this.map.setView(marker.getLatLng(), 18);
                            marker.openPopup();
                        }
                    };
                    
                    list.appendChild(item);
                });
            },
            
            addNewSensor() {
                console.log('Ajout nouveau capteur - Mode placement activé');
                
                // Désactiver les autres modes
                if (this.state.enemyMode) this.toggleEnemyMode();
                if (this.state.drawMode) this.toggleDrawMode();
                if (this.state.editMode) this.toggleEditMode();
                
                this.map.getContainer().style.cursor = 'crosshair';
                this.notify('📍 Cliquez sur la carte pour placer le capteur');
                
                // Variable pour stocker le handler temporaire
                const placeSensorHandler = (e) => {
                    console.log('Clic pour placement capteur à:', e.latlng);
                    
                    // Retirer le handler
                    this.map.off('click', placeSensorHandler);
                    this.map.getContainer().style.cursor = '';
                    
                    // Demander le nom du capteur
                    const name = prompt('Nom du capteur (ex: SENSOR_01):', 'SENSOR_' + Date.now().toString().slice(-4));
                    if (!name) {
                        this.notify('Placement annulé');
                        return;
                    }
                    
                    const sensorData = {
                        name: name,
                        type: 'IR',
                        status: 'active',
                        position: {
                            lat: e.latlng.lat,
                            lng: e.latlng.lng
                        },
                        timestamp: Date.now(),
                        placedBy: this.state.playerName,
                        manual: true  // Indique placement manuel
                    };
                    
                    console.log('Création capteur:', sensorData);
                    
                    // Sauvegarder dans Firebase
                    if (this.state.isConnected && this.firebase.db) {
                        const sensorRef = ref(this.firebase.db, 
                            `sensors/${this.state.teamCode}/${name}`);
                        set(sensorRef, sensorData).then(() => {
                            console.log('Capteur sauvegardé dans Firebase');
                            this.notify('📡 Capteur ajouté : ' + name);
                        }).catch(err => {
                            console.error('Erreur sauvegarde:', err);
                            this.notify('❌ Erreur ajout capteur');
                        });
                    } else {
                        // Mode hors ligne
                        this.state.sensors[name] = { data: sensorData };
                        this.createSensorMarker(name, sensorData);
                        this.notify('📡 Capteur ajouté localement');
                    }
                };
                
                // Attacher le handler temporaire
                this.map.once('click', placeSensorHandler);
                
                // Timeout pour annuler si pas de clic
                setTimeout(() => {
                    if (this.map.hasEventListeners('click', placeSensorHandler)) {
                        this.map.off('click', placeSensorHandler);
                        this.map.getContainer().style.cursor = '';
                        this.notify('Placement annulé');
                    }
                }, 30000);  // 30 secondes
            },
            
            triggerSensor(id) {
                if (this.state.isConnected && this.firebase.db) {
                    const cmdRef = ref(this.firebase.db, 
                        `sensors/${this.state.teamCode}/${id}/command`);
                    set(cmdRef, 'test');
                    this.notify('📡 Test envoyé');
                }
            },
            
            removeSensor(id) {
                if (confirm('Supprimer ce capteur?')) {
                    if (this.state.isConnected && this.firebase.db) {
                        const sensorRef = ref(this.firebase.db, 
                            `sensors/${this.state.teamCode}/${id}`);
                        remove(sensorRef);
                    }
                    this.map.closePopup();
                }
            },

            onMapClick(e) {
                console.log('Map click:', e.latlng, 'Mode actuel:', {
                    enemy: this.state.enemyMode,
                    draw: this.state.drawMode,
                    edit: this.state.editMode,
                    sensor: this.state.sensorMode
                });
                
                if (this.state.enemyMode) {
                    this.addEnemy(e.latlng);
                    this.toggleEnemyMode();
                } else if (this.state.drawMode && !this.state.editMode) {
                    // Ne dessiner que si on est en mode dessin ET pas en mode édition
                    if (this.state.drawTool === 'rectangle' || this.state.drawTool === 'circle') {
                        if (!this.state.isDrawing) {
                            this.startDrawing(e.latlng);
                        } else {
                            this.finishDrawing(e.latlng);
                        }
                    } else if (this.state.drawTool === 'polygon') {
                        this.addPolygonPoint(e.latlng);
                    } else if (this.state.drawTool === 'line') {
                        this.addLinePoint(e.latlng);
                    }
                }
                // En mode édition, ne rien faire sur la carte (seulement sur les obstacles)
            },

            onMapMove(e) {
                if (this.state.drawMode && this.state.isDrawing) {
                    this.updatePreview(e.latlng);
                }
            },
            
            onMapRightClick(e) {
                if (this.state.drawMode) {
                    e.originalEvent.preventDefault();
                    
                    if (this.state.drawTool === 'polygon' && this.state.polygonPoints.length >= 3) {
                        this.finishPolygon();
                    } else if (this.state.drawTool === 'line' && this.state.linePoints.length >= 2) {
                        this.finishLine();
                    }
                }
            },
            
            onMapDoubleClick(e) {
                if (this.state.drawMode) {
                    e.originalEvent.preventDefault();
                    e.originalEvent.stopPropagation();
                    
                    if (this.state.drawTool === 'polygon' && this.state.polygonPoints.length >= 3) {
                        this.finishPolygon();
                    } else if (this.state.drawTool === 'line' && this.state.linePoints.length >= 2) {
                        this.finishLine();
                    }
                }
            },

            addEnemy(latlng) {
                // Validation des coordonnées
                if (!latlng || !latlng.lat || !latlng.lng) {
                    console.error('Position invalide pour ennemi:', latlng);
                    return;
                }
                
                // Vérifier qu'on a bien une équipe
                if (!this.state.teamCode) {
                    console.error('Pas de code équipe défini!');
                    this.notify('❌ Erreur: pas d\'équipe');
                    return;
                }
                
                const id = 'enemy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                const data = {
                    lat: parseFloat(latlng.lat.toFixed(6)),
                    lng: parseFloat(latlng.lng.toFixed(6)),
                    reportedBy: this.state.playerName || 'JOUEUR',
                    timestamp: Date.now(),
                    expiresAt: Date.now() + 30000,
                    teamCode: this.state.teamCode // Ajouter le code équipe dans les données
                };

                console.log('=== AJOUT ENNEMI ===');
                console.log('ID:', id);
                console.log('Position:', data.lat, data.lng);
                console.log('Équipe:', this.state.teamCode);
                console.log('Joueur:', this.state.playerName);
                console.log('Firebase connecté:', this.state.isConnected);
                console.log('Path Firebase:', `enemies/${this.state.teamCode}/${id}`);

                // Toujours créer localement d'abord pour feedback immédiat
                this.createEnemyMarker(id, data);
                
                // Puis partager si connecté
                if (this.state.isConnected && this.firebase.db && this.state.teamCode) {
                    console.log('Envoi à Firebase...');
                    const enemyPath = `enemies/${this.state.teamCode}/${id}`;
                    const enemyRef = ref(this.firebase.db, enemyPath);
                    
                    set(enemyRef, data)
                        .then(() => {
                            console.log('✅ Ennemi envoyé avec succès à:', enemyPath);
                            
                            // Vérifier immédiatement si l'écriture a fonctionné
                            onValue(enemyRef, (snap) => {
                                console.log('Vérification écriture:', snap.val());
                            }, { onlyOnce: true });
                        })
                        .catch(err => {
                            console.error('❌ ERREUR envoi Firebase:', err);
                            console.error('Détails erreur:', err.code, err.message);
                            this.notify('❌ Erreur partage ennemi');
                        });
                } else {
                    console.log('Mode hors ligne - pas d\'envoi Firebase');
                    if (!this.state.isConnected) console.log('Raison: Pas connecté');
                    if (!this.firebase.db) console.log('Raison: Firebase non initialisé');
                    if (!this.state.teamCode) console.log('Raison: Pas de code équipe');
                }

                this.notify('🎯 Ennemi marqué (30s)');
                if (navigator.vibrate) navigator.vibrate(200);
            },

            createEnemyMarker(id, data) {
                if (this.markers.enemies[id]) return;

                // Vérifier que les coordonnées sont valides
                if (!data.lat || !data.lng) {
                    console.error('Coordonnées invalides pour ennemi:', data);
                    return;
                }
                
                // Calculer la distance si on a notre position
                let distanceText = '';
                if (this.state.position && this.state.position.lat && this.state.position.lng) {
                    const distance = this.calculateDistance(
                        this.state.position.lat, 
                        this.state.position.lng,
                        data.lat,
                        data.lng
                    );
                    distanceText = `${distance}m`;
                }

                const icon = L.divIcon({
                    className: '',
                    html: `<div style="position: relative; width: 30px; height: 30px;">
                               <div style="width: 30px; height: 30px; 
                                           background: radial-gradient(circle, #ff0000, #cc0000);
                                           border: 3px solid #ffff00;
                                           border-radius: 50%;
                                           box-shadow: 0 0 20px #ff0000;
                                           animation: enemyPulse 1s infinite;"></div>
                               <div style="position: absolute; top: -25px; left: 50%; transform: translateX(-50%); 
                                           background: #ff0000; color: white; padding: 3px 8px; border-radius: 4px; 
                                           font-size: 10px; font-weight: bold; white-space: nowrap;
                                           border: 1px solid #ffff00; text-align: center;">
                                   ⚠️ ${data.reportedBy || 'ENNEMI'}<br>
                                   <span style="font-size: 12px; font-weight: bold;">${distanceText}</span>
                               </div>
                           </div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });

                // Créer le marqueur dans le pane spécial pour être au-dessus
                const marker = L.marker([data.lat, data.lng], {
                    icon,
                    pane: 'enemyPane',  // Pane personnalisé au-dessus des tooltips
                    draggable: false,
                    autoPan: false
                }).addTo(this.map);

                this.markers.enemies[id] = marker;
                marker._enemyData = data;  // Stocker les données pour mise à jour
                console.log(`Ennemi créé à position fixe: ${data.lat}, ${data.lng} - Distance: ${distanceText}`);

                // Auto-suppression après 30 secondes
                const timeoutId = setTimeout(() => {
                    if (this.markers.enemies[id]) {
                        this.map.removeLayer(this.markers.enemies[id]);
                        delete this.markers.enemies[id];
                        
                        if (this.state.isConnected) {
                            const enemyRef = ref(this.firebase.db, `enemies/${this.state.teamCode}/${id}`);
                            remove(enemyRef);
                        }
                    }
                }, 30000);

                // Stocker le timeout pour pouvoir l'annuler si besoin
                marker._timeoutId = timeoutId;
            },
            
            // Fonction pour calculer la distance entre deux points GPS
            calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371000; // Rayon de la Terre en mètres
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const distance = R * c;
                return Math.round(distance); // Distance en mètres
            },
            
            // Mettre à jour les distances des ennemis quand le joueur bouge
            updateEnemyDistances() {
                if (!this.state.position) return;
                
                Object.keys(this.markers.enemies).forEach(id => {
                    const marker = this.markers.enemies[id];
                    if (marker && marker._enemyData) {
                        const data = marker._enemyData;
                        const distance = this.calculateDistance(
                            this.state.position.lat,
                            this.state.position.lng,
                            data.lat,
                            data.lng
                        );
                        
                        // Mettre à jour l'icône avec la nouvelle distance
                        const newIcon = L.divIcon({
                            className: '',
                            html: `<div style="position: relative; width: 30px; height: 30px;">
                                       <div style="width: 30px; height: 30px; 
                                                   background: radial-gradient(circle, #ff0000, #cc0000);
                                                   border: 3px solid #ffff00;
                                                   border-radius: 50%;
                                                   box-shadow: 0 0 20px #ff0000;
                                                   animation: enemyPulse 1s infinite;"></div>
                                       <div style="position: absolute; top: -25px; left: 50%; transform: translateX(-50%); 
                                                   background: #ff0000; color: white; padding: 3px 8px; border-radius: 4px; 
                                                   font-size: 10px; font-weight: bold; white-space: nowrap;
                                                   border: 1px solid #ffff00; text-align: center;">
                                           ⚠️ ${data.reportedBy || 'ENNEMI'}<br>
                                           <span style="font-size: 12px; font-weight: bold;">${distance}m</span>
                                       </div>
                                   </div>`,
                            iconSize: [30, 30],
                            iconAnchor: [15, 15]
                        });
                        
                        marker.setIcon(newIcon);
                    }
                });
            },

            startDrawing(latlng) {
                this.state.isDrawing = true;
                this.state.drawStart = latlng;
            },

            updatePreview(latlng) {
                if (this.state.preview) {
                    this.map.removeLayer(this.state.preview);
                }

                if (this.state.drawTool === 'rectangle') {
                    this.state.preview = L.rectangle([this.state.drawStart, latlng], {
                        color: this.state.drawColor,
                        weight: 1,
                        fillOpacity: 0.1,
                        dashArray: '5, 5'
                    });
                } else {
                    const radius = this.map.distance(this.state.drawStart, latlng);
                    this.state.preview = L.circle(this.state.drawStart, {
                        radius,
                        color: this.state.drawColor,
                        weight: 1,
                        fillOpacity: 0.1,
                        dashArray: '5, 5'
                    });
                }

                this.state.preview.addTo(this.map);
            },

            finishDrawing(latlng) {
                if (this.state.preview) {
                    this.map.removeLayer(this.state.preview);
                    this.state.preview = null;
                }

                // Vérifier qu'il n'y a pas déjà un popup ouvert
                if (document.querySelector('.obstacle-text-popup')) {
                    return;
                }

                // Demander le texte à l'utilisateur
                this.showTextPrompt((text) => {
                    const id = 'obs_' + Date.now();
                    let data = {
                        type: this.state.drawTool,
                        color: this.state.drawColor,
                        createdBy: this.state.playerName,
                        timestamp: Date.now(),
                        text: text || ''
                    };

                    if (this.state.drawTool === 'rectangle') {
                        const bounds = L.latLngBounds(this.state.drawStart, latlng);
                        data.bounds = {
                            north: bounds.getNorth(),
                            south: bounds.getSouth(),
                            east: bounds.getEast(),
                            west: bounds.getWest()
                        };
                    } else {
                        data.center = {lat: this.state.drawStart.lat, lng: this.state.drawStart.lng};
                        data.radius = this.map.distance(this.state.drawStart, latlng);
                    }

                    // Sauvegarder si connecté
                    if (this.state.isConnected && this.firebase.db) {
                        const obsRef = ref(this.firebase.db, `obstacles/${this.state.teamCode}/${id}`);
                        set(obsRef, data);
                    } else {
                        // Ajouter localement si pas connecté
                        console.log('Mode hors ligne - ajout local de l\'obstacle');
                        // Forcer la mise à jour locale
                        setTimeout(() => {
                            onValue(this.firebase.refs.obstacles, (snap) => {
                                const currentData = snap.val() || {};
                                currentData[id] = data;
                                this.updateObstacles(currentData);
                            }, { onlyOnce: true });
                        }, 100);
                    }

                    this.state.isDrawing = false;
                    this.state.drawStart = null;
                    this.notify('Obstacle créé');
                });
            },

            setDrawTool(tool) {
                // Nettoyer l'outil précédent
                this.clearTempMarkers();
                this.state.polygonPoints = [];
                this.state.linePoints = [];
                if (this.state.preview) {
                    this.map.removeLayer(this.state.preview);
                    this.state.preview = null;
                }
                this.state.isDrawing = false;
                this.state.drawStart = null;
                
                // Définir le nouvel outil
                this.state.drawTool = tool;
                document.querySelectorAll('#drawPanel .btn').forEach(b => b.classList.remove('active'));
                event.target.classList.add('active');
                
                // Instructions selon l'outil
                if (tool === 'polygon') {
                    this.notify('Cliquez pour dessiner un polygone');
                } else if (tool === 'line') {
                    this.notify('Cliquez pour dessiner une ligne');
                } else if (tool === 'rectangle') {
                    this.notify('Cliquez et maintenez pour dessiner');
                } else if (tool === 'circle') {
                    this.notify('Cliquez au centre puis définissez le rayon');
                }
            },

            setDrawColor(color, e) {
                this.state.drawColor = color;
                document.querySelectorAll('.color').forEach(c => c.classList.remove('active'));
                e.target.classList.add('active');
            },
            
            // Nouvelles méthodes pour les formes personnalisées
            addPolygonPoint(latlng) {
                this.state.polygonPoints.push(latlng);
                
                // Ajouter un marqueur temporaire
                const marker = L.circleMarker(latlng, {
                    radius: 5,
                    color: this.state.drawColor,
                    fillColor: this.state.drawColor,
                    fillOpacity: 0.8
                });
                marker.addTo(this.map);
                this.state.tempMarkers.push(marker);
                
                // Mettre à jour l'aperçu
                if (this.state.preview) {
                    this.map.removeLayer(this.state.preview);
                }
                
                if (this.state.polygonPoints.length >= 2) {
                    this.state.preview = L.polyline(this.state.polygonPoints, {
                        color: this.state.drawColor,
                        dashArray: '5, 5'
                    });
                    this.state.preview.addTo(this.map);
                }
                
                // Instructions
                if (this.state.polygonPoints.length === 1) {
                    this.notify('Continuez à cliquer pour ajouter des points');
                } else if (this.state.polygonPoints.length >= 3) {
                    this.notify('Clic droit ou double-clic pour terminer');
                }
            },
            
            addLinePoint(latlng) {
                this.state.linePoints.push(latlng);
                
                // Ajouter un marqueur temporaire
                const marker = L.circleMarker(latlng, {
                    radius: 5,
                    color: this.state.drawColor,
                    fillColor: this.state.drawColor,
                    fillOpacity: 0.8
                });
                marker.addTo(this.map);
                this.state.tempMarkers.push(marker);
                
                // Mettre à jour l'aperçu
                if (this.state.preview) {
                    this.map.removeLayer(this.state.preview);
                }
                
                if (this.state.linePoints.length >= 2) {
                    this.state.preview = L.polyline(this.state.linePoints, {
                        color: this.state.drawColor,
                        weight: 4
                    });
                    this.state.preview.addTo(this.map);
                }
                
                // Instructions
                if (this.state.linePoints.length === 1) {
                    this.notify('Cliquez pour ajouter le point suivant');
                } else {
                    this.notify('Clic droit ou double-clic pour terminer');
                }
            },
            
            clearTempMarkers() {
                this.state.tempMarkers.forEach(marker => {
                    this.map.removeLayer(marker);
                });
                this.state.tempMarkers = [];
            },
            
            finishPolygon() {
                if (this.state.polygonPoints.length < 3) {
                    this.notify('Un polygone nécessite au moins 3 points');
                    return;
                }
                
                // Vérifier qu'il n'y a pas déjà un popup ouvert
                if (document.querySelector('.obstacle-text-popup')) {
                    return;
                }
                
                this.showTextPrompt((text) => {
                    const id = 'obs_' + Date.now();
                    const data = {
                        type: 'polygon',
                        color: this.state.drawColor,
                        createdBy: this.state.playerName,
                        timestamp: Date.now(),
                        points: this.state.polygonPoints.map(p => ({lat: p.lat, lng: p.lng})),
                        text: text || ''
                    };
                    
                    if (this.state.isConnected && this.firebase.db) {
                        const obsRef = ref(this.firebase.db, `obstacles/${this.state.teamCode}/${id}`);
                        set(obsRef, data);
                    } else {
                        // Ajouter localement si pas connecté
                        console.log('Mode hors ligne - ajout local du polygone');
                    }
                    
                    // Nettoyer
                    this.clearTempMarkers();
                    if (this.state.preview) {
                        this.map.removeLayer(this.state.preview);
                        this.state.preview = null;
                    }
                    this.state.polygonPoints = [];
                    this.notify('Polygone créé');
                });
            },
            
            finishLine() {
                if (this.state.linePoints.length < 2) {
                    this.notify('Une ligne nécessite au moins 2 points');
                    return;
                }
                
                // Vérifier qu'il n'y a pas déjà un popup ouvert
                if (document.querySelector('.obstacle-text-popup')) {
                    return;
                }
                
                this.showTextPrompt((text) => {
                    const id = 'obs_' + Date.now();
                    const data = {
                        type: 'line',
                        color: this.state.drawColor,
                        createdBy: this.state.playerName,
                        timestamp: Date.now(),
                        points: this.state.linePoints.map(p => ({lat: p.lat, lng: p.lng})),
                        text: text || ''
                    };
                    
                    if (this.state.isConnected && this.firebase.db) {
                        const obsRef = ref(this.firebase.db, `obstacles/${this.state.teamCode}/${id}`);
                        set(obsRef, data);
                    } else {
                        // Ajouter localement si pas connecté
                        console.log('Mode hors ligne - ajout local de la ligne');
                    }
                    
                    // Nettoyer
                    this.clearTempMarkers();
                    if (this.state.preview) {
                        this.map.removeLayer(this.state.preview);
                        this.state.preview = null;
                    }
                    this.state.linePoints = [];
                    this.notify('Ligne créée');
                });
            },
            
            showTextPrompt(callback) {
                // Créer la popup
                const popup = document.createElement('div');
                popup.className = 'obstacle-text-popup';
                popup.innerHTML = `
                    <h3>Ajouter un texte (optionnel)</h3>
                    <input type="text" id="obstacleText" placeholder="Ex: Zone de tir, Mur..." maxlength="20">
                    <div>
                        <button id="textOkBtn">OK</button>
                        <button id="textCancelBtn" class="cancel">Annuler</button>
                    </div>
                `;
                document.body.appendChild(popup);
                
                // Stocker le callback
                this._textCallback = callback;
                
                // Ajouter les événements aux boutons
                document.getElementById('textOkBtn').addEventListener('click', () => {
                    this.submitText();
                });
                
                document.getElementById('textCancelBtn').addEventListener('click', () => {
                    this.submitText(true);
                });
                
                // Focus sur l'input
                setTimeout(() => {
                    const input = document.getElementById('obstacleText');
                    if (input) input.focus();
                }, 100);
                
                // Gérer Enter pour valider
                document.getElementById('obstacleText').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.submitText();
                    }
                });
                
                // Gérer Escape pour annuler
                document.addEventListener('keydown', this._escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.submitText(true);
                    }
                });
            },
            
            submitText(cancel = false) {
                const popup = document.querySelector('.obstacle-text-popup');
                const textInput = document.getElementById('obstacleText');
                const text = cancel ? '' : (textInput ? textInput.value.trim() : '');
                
                // Retirer le handler Escape
                if (this._escapeHandler) {
                    document.removeEventListener('keydown', this._escapeHandler);
                    this._escapeHandler = null;
                }
                
                if (popup) {
                    popup.remove();
                }
                
                if (this._textCallback) {
                    this._textCallback(text);
                    this._textCallback = null;
                }
            },

            showQRCode() {
                console.log('=== SHOW QR CODE ===');
                console.log('Team Code:', this.state.teamCode);
                console.log('Player Name:', this.state.playerName);
                
                // Si pas de team, montrer l'écran de config
                if (!this.state.teamCode || this.state.teamCode === '') {
                    console.log('Pas de team - affichage config');
                    document.getElementById('setupScreen').classList.remove('hidden');
                    document.getElementById('map').classList.add('hidden');
                    document.getElementById('gameHUD').classList.add('hidden');
                    return;
                }

                try {
                    const modal = document.getElementById('qrModal');
                    const img = document.getElementById('qrcode');
                    const span = document.getElementById('qrTeamCode');
                    
                    console.log('Modal existe?', modal !== null);
                    console.log('Image existe?', img !== null);
                    console.log('Span existe?', span !== null);
                    
                    if (!modal || !img || !span) {
                        console.error('Éléments manquants');
                        // Fallback avec alert
                        const url = `${window.location.origin}${window.location.pathname}?team=${this.state.teamCode}`;
                        alert(`📡 ÉQUIPE: ${this.state.teamCode}\n\nPartagez cette URL:\n${url}`);
                        return;
                    }

                    // Afficher le code équipe
                    span.textContent = this.state.teamCode;
                    
                    // Générer l'URL
                    const url = `${window.location.origin}${window.location.pathname}?team=${encodeURIComponent(this.state.teamCode)}`;
                    console.log('URL générée:', url);
                    
                    // Générer le QR code
                    const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(url)}`;
                    console.log('QR URL:', qrUrl);
                    
                    img.src = qrUrl;
                    img.onload = () => console.log('QR Code chargé');
                    img.onerror = () => {
                        console.error('Erreur QR - tentative Google Charts');
                        img.src = `https://chart.googleapis.com/chart?chs=200x200&cht=qr&chl=${encodeURIComponent(url)}`;
                    };
                    
                    // Vérifier si l'installation PWA est disponible
                    const installBtn = document.getElementById('installBtn');
                    if (installBtn) {
                        if (this.state.deferredPrompt) {
                            installBtn.style.display = 'inline-block';
                            console.log('Bouton installation affiché');
                        } else {
                            installBtn.style.display = 'inline-block'; // Toujours montrer pour les instructions
                        }
                    }
                    
                    // Forcer l'affichage
                    modal.style.display = 'flex';
                    modal.style.visibility = 'visible';
                    modal.style.zIndex = '20000';
                    
                    console.log('Modal affichée');
                    this.notify('📲 QR Code généré');
                    
                } catch (error) {
                    console.error('ERREUR showQRCode:', error);
                    alert(`Erreur QR!\nCode équipe: ${this.state.teamCode}`);
                }
            },
            
            installPWA() {
                console.log('Installation PWA demandée');
                
                if (this.state.deferredPrompt) {
                    // Prompt d'installation disponible
                    this.state.deferredPrompt.prompt();
                    this.state.deferredPrompt.userChoice.then(result => {
                        if (result.outcome === 'accepted') {
                            console.log('Installation acceptée');
                            this.notify('📲 Installation lancée!');
                        } else {
                            console.log('Installation refusée');
                        }
                        this.state.deferredPrompt = null;
                    });
                } else {
                    // Pas de prompt disponible - donner les instructions manuelles
                    alert(
                        '📲 INSTALLER L\'APPLICATION\n\n' +
                        '🤖 ANDROID (Chrome/Edge):\n' +
                        '1. Menu ⋮ (3 points)\n' +
                        '2. "Installer l\'application"\n' +
                        'ou "Ajouter à l\'écran d\'accueil"\n\n' +
                        '🍎 iOS (Safari):\n' +
                        '1. Bouton partage ⬆️\n' +
                        '2. "Sur l\'écran d\'accueil"\n\n' +
                        'ℹ️ Si déjà installée avant:\n' +
                        'Videz le cache du navigateur\n' +
                        'ou utilisez un autre navigateur'
                    );
                }
            },
            
            changeTeam() {
                if (confirm('Changer d\'équipe? Vous serez déconnecté de l\'équipe actuelle.')) {
                    // Nettoyer Firebase
                    if (this.state.isConnected && this.state.teamCode && this.state.playerName) {
                        const playerRef = ref(this.firebase.db, `teams/${this.state.teamCode}/${this.state.playerName}`);
                        remove(playerRef);
                    }
                    
                    // Réinitialiser
                    this.state.teamCode = null;
                    this.state.playerName = null;
                    
                    // Retour config
                    this.closeModal();
                    document.getElementById('setupScreen').classList.remove('hidden');
                    document.getElementById('map').classList.add('hidden');
                    document.getElementById('gameHUD').classList.add('hidden');
                }
            },

            closeModal() {
                document.getElementById('qrModal').style.display = 'none';
            },

            copyTeamLink() {
                const url = `${window.location.origin}${window.location.pathname}?team=${this.state.teamCode}`;
                navigator.clipboard.writeText(url).then(() => {
                    this.notify('Lien copié!');
                });
            },

            centerPlayer() {
                if (this.state.position) {
                    this.map.setView([this.state.position.lat, this.state.position.lng], 17);
                }
            },
            
            zoomIn() {
                const currentZoom = this.map.getZoom();
                if (currentZoom < 21) {
                    this.map.setZoom(currentZoom + 1);
                }
            },
            
            zoomOut() {
                const currentZoom = this.map.getZoom();
                if (currentZoom > 1) {
                    this.map.setZoom(currentZoom - 1);
                }
            },

            recalibrateGPS() {
                if (this.state.watchId) {
                    navigator.geolocation.clearWatch(this.state.watchId);
                }
                this.initGPS();
                this.notify('GPS recalibré');
            },

            switchLayer(type) {
                Object.values(this.layers).forEach(l => this.map.removeLayer(l));
                this.layers[type].addTo(this.map);
                
                document.querySelectorAll('.layer-btn').forEach(b => b.classList.remove('active'));
                event.target.classList.add('active');
            },

            updateStatus(id, text) {
                const el = document.getElementById(id);
                if (el) el.textContent = text;
            },

            updateLoading(text) {
                document.getElementById('loadingStatus').textContent = text;
            },

            notify(message) {
                const notif = document.createElement('div');
                notif.className = 'notification';
                notif.textContent = message;
                document.body.appendChild(notif);
                setTimeout(() => notif.remove(), 3000);
            }
        };

        // Exposer globalement
        window.App = App;
        
        // Fonction de debug pour tester
        window.testQR = function() {
            console.log('=== TEST QR DIRECT ===');
            console.log('App.state.teamCode:', App.state.teamCode);
            
            // Test avec équipe forcée si pas définie
            if (!App.state.teamCode) {
                App.state.teamCode = 'TEST123';
                console.log('Team forcée à TEST123');
            }
            
            // Appeler la fonction
            App.showQRCode();
        };
        
        window.debugApp = function() {
            console.log('=== DEBUG APP ===');
            console.log('Team:', App.state.teamCode);
            console.log('Player:', App.state.playerName); 
            console.log('Connected:', App.state.isConnected);
            console.log('Obstacles group:', App.groups.obstacles);
            console.log('Map has obstacles layer:', App.map && App.map.hasLayer(App.groups.obstacles));
            console.log('Firebase refs:', App.firebase.refs);
            console.log('Ennemis locaux:', Object.keys(App.markers.enemies));
            
            // Forcer le rechargement des obstacles
            if (App.firebase.refs.obstacles) {
                onValue(App.firebase.refs.obstacles, (snap) => {
                    console.log('Obstacles dans Firebase:', snap.val());
                    App.updateObstacles(snap.val());
                }, { onlyOnce: true });
            }
            
            // Vérifier les ennemis dans Firebase
            if (App.firebase.refs.enemies) {
                onValue(App.firebase.refs.enemies, (snap) => {
                    const enemies = snap.val();
                    console.log('Ennemis dans Firebase:', enemies);
                    if (enemies) {
                        console.log('Nombre d\'ennemis Firebase:', Object.keys(enemies).length);
                        Object.keys(enemies).forEach(id => {
                            console.log(`- ${id}:`, enemies[id].reportedBy, 'à', enemies[id].lat, enemies[id].lng);
                        });
                    }
                }, { onlyOnce: true });
            }
        };
        
        // Test d'ajout d'ennemi
        window.testEnemy = function() {
            console.log('=== TEST AJOUT ENNEMI ===');
            const testPos = {
                lat: 48.8566 + (Math.random() - 0.5) * 0.001,
                lng: 2.3522 + (Math.random() - 0.5) * 0.001
            };
            console.log('Position test:', testPos);
            App.addEnemy(testPos);
        };
        
        // IMPORTANT: Exposer les fonctions pour les popups
        window.removeObstacle = function(id) {
            App.removeObstacle(id);
        };

        // Charger config au démarrage
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const sharedTeam = urlParams.get('team');
            
            if (sharedTeam) {
                document.getElementById('teamCode').value = sharedTeam.toUpperCase();
                window.history.replaceState({}, document.title, window.location.pathname);
            } else {
                const saved = localStorage.getItem('airsoftConfig');
                if (saved) {
                    const config = JSON.parse(saved);
                    document.getElementById('teamCode').value = config.teamCode || '';
                    document.getElementById('playerName').value = config.playerName || '';
                }
            }
            
            // Enregistrer le Service Worker pour PWA
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js').then(reg => {
                    console.log('Service Worker enregistré');
                }).catch(err => {
                    console.log('Service Worker non disponible');
                });
            }
            
            // Capturer l'événement d'installation PWA
            window.addEventListener('beforeinstallprompt', (e) => {
                console.log('Installation PWA disponible');
                e.preventDefault();
                App.state.deferredPrompt = e;
                
                // Mettre à jour le bouton si la modal est ouverte
                const installBtn = document.getElementById('installBtn');
                if (installBtn) {
                    installBtn.style.display = 'inline-block';
                }
            });
            
            // Détection de l'installation
            window.addEventListener('appinstalled', () => {
                console.log('PWA installée avec succès');
                App.notify('✅ Application installée!');
                App.state.deferredPrompt = null;
            });
        });
        
        // Debug pour la synchronisation des ennemis
        window.checkFirebaseSync = function() {
            console.log('=== DIAGNOSTIC SYNCHRONISATION ENNEMIS ===');
            console.log('1. État local:');
            console.log('   - Équipe:', App.state.teamCode);
            console.log('   - Joueur:', App.state.playerName);
            console.log('   - Connecté:', App.state.isConnected);
            console.log('   - Ennemis locaux:', Object.keys(App.markers.enemies));
            
            if (!App.firebase.db) {
                console.error('❌ Firebase non initialisé !');
                return;
            }
            
            if (!App.state.teamCode) {
                console.error('❌ Pas de code équipe !');
                return;
            }
            
            // Vérifier le path Firebase
            const enemiesPath = `enemies/${App.state.teamCode}`;
            console.log('2. Path Firebase des ennemis:', enemiesPath);
            
            // Lire directement depuis Firebase
            import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js').then(({ ref, onValue }) => {
                const enemiesRef = ref(App.firebase.db, enemiesPath);
                
                onValue(enemiesRef, (snapshot) => {
                    const data = snapshot.val();
                    console.log('3. Données brutes Firebase:');
                    console.log(data);
                    
                    if (data) {
                        console.log('4. Analyse des ennemis:');
                        Object.keys(data).forEach(id => {
                            const enemy = data[id];
                            const isLocal = App.markers.enemies[id] ? '✅ Affiché' : '❌ Non affiché';
                            const isExpired = enemy.expiresAt && Date.now() > enemy.expiresAt ? '⏰ Expiré' : '✓ Valide';
                            console.log(`   - ${id}: par ${enemy.reportedBy} ${isLocal} ${isExpired}`);
                            console.log(`     Position: ${enemy.lat}, ${enemy.lng}`);
                        });
                    } else {
                        console.log('4. Aucun ennemi dans Firebase');
                    }
                    
                    console.log('5. Test de lecture/écriture:');
                    console.log('   Pour tester l\'ajout, tapez: testEnemy()');
                    console.log('   Pour forcer la mise à jour, tapez: App.updateEnemies(' + JSON.stringify(data) + ')');
                }, { onlyOnce: true });
            });
        };
        
        // Debug pour les obstacles
        window.debugObstacles = function() {
            console.log('=== DIAGNOSTIC OBSTACLES ===');
            
            if (!App.groups.obstacles) {
                console.error('❌ Groupe obstacles non initialisé !');
                return;
            }
            
            console.log('1. Analyse du groupe obstacles:');
            let count = 0;
            let withId = 0;
            let withData = 0;
            let paths = 0;
            
            App.groups.obstacles.eachLayer(layer => {
                count++;
                if (layer._obstacleId) withId++;
                if (layer._obstacleData) withData++;
                if (layer instanceof L.Path) paths++;
                
                console.log(`   Layer ${count}:`, {
                    type: layer.constructor.name,
                    hasId: !!layer._obstacleId,
                    id: layer._obstacleId,
                    hasData: !!layer._obstacleData,
                    data: layer._obstacleData,
                    interactive: layer.options?.interactive,
                    isPath: layer instanceof L.Path
                });
            });
            
            console.log('2. Résumé:');
            console.log(`   - Total layers: ${count}`);
            console.log(`   - Avec ID: ${withId}`);
            console.log(`   - Avec Data: ${withData}`);
            console.log(`   - Paths (formes): ${paths}`);
            console.log(`   - Mode édition actif: ${App.state.editMode}`);
            
            console.log('3. Pour activer le mode édition:');
            console.log('   App.toggleEditMode()');
        };
        
        // Debug pour les capteurs
        window.debugSensors = function() {
            console.log('=== DIAGNOSTIC CAPTEURS ===');
            
            console.log('1. État local:');
            console.log('   - Mode capteur actif:', App.state.sensorMode);
            console.log('   - Capteurs en mémoire:', App.state.sensors);
            console.log('   - Nombre de capteurs:', Object.keys(App.state.sensors).length);
            
            console.log('2. Détails des capteurs:');
            Object.keys(App.state.sensors).forEach(id => {
                const sensor = App.state.sensors[id];
                console.log(`   ${id}:`, {
                    data: sensor.data,
                    marker: !!sensor.marker,
                    position: sensor.data?.position
                });
            });
            
            console.log('3. Vérification Firebase:');
            if (App.firebase.refs && App.firebase.refs.sensors) {
                import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js').then(({ onValue }) => {
                    onValue(App.firebase.refs.sensors, (snap) => {
                        const data = snap.val();
                        console.log('   Données Firebase brutes:', data);
                        if (data) {
                            Object.keys(data).forEach(id => {
                                console.log(`   - ${id}:`, data[id]);
                            });
                        }
                    }, { onlyOnce: true });
                });
            } else {
                console.log('   ❌ Référence Firebase non initialisée');
            }
            
            console.log('4. Pour forcer le rechargement:');
            console.log('   App.updateSensors(null); // Effacer');
            console.log('   // Puis recharger depuis Firebase');
        };
        
        // Forcer le rechargement des capteurs
        window.reloadSensors = function() {
            console.log('Rechargement forcé des capteurs...');
            
            if (!App.firebase.refs || !App.firebase.refs.sensors) {
                console.error('Firebase non prêt');
                return;
            }
            
            // Effacer les capteurs existants
            Object.keys(App.state.sensors).forEach(id => {
                if (App.state.sensors[id].marker) {
                    App.map.removeLayer(App.state.sensors[id].marker);
                }
            });
            App.state.sensors = {};
            
            // Recharger depuis Firebase
            import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js').then(({ onValue }) => {
                onValue(App.firebase.refs.sensors, (snap) => {
                    const data = snap.val();
                    console.log('Capteurs rechargés:', data);
                    App.updateSensors(data);
                }, { onlyOnce: true });
            });
        };
        
        // Forcer une synchronisation manuelle
        window.forceEnemySync = function() {
            console.log('=== FORÇAGE SYNCHRONISATION ===');
            
            if (!App.firebase.db || !App.state.teamCode) {
                console.error('Firebase non prêt');
                return;
            }
            
            import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js').then(({ ref, onValue, off }) => {
                const enemiesRef = ref(App.firebase.db, `enemies/${App.state.teamCode}`);
                
                // Retirer l'ancien listener
                if (App.firebase.refs.enemies) {
                    off(App.firebase.refs.enemies);
                    console.log('Ancien listener supprimé');
                }
                
                // Créer un nouveau listener
                App.firebase.refs.enemies = enemiesRef;
                onValue(enemiesRef, (snapshot) => {
                    console.log('Nouvelle synchronisation forcée');
                    const data = snapshot.val();
                    console.log('Données reçues:', data);
                    App.updateEnemies(data);
                });
                
                console.log('✅ Nouveau listener installé');
            });
        };

        // Nettoyage
        window.addEventListener('beforeunload', () => {
            if (App.state.watchId) {
                navigator.geolocation.clearWatch(App.state.watchId);
            }
        });
    </script>
</body>
</html>
