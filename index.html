<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a1a">
    <title>Airsoft Tactical Pro</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #000; color: #00ff00; overflow: hidden; }
        
        .setup-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            z-index: 10000;
        }
        
        .setup-box {
            background: #1a1a1a; padding: 30px; border-radius: 15px;
            border: 2px solid #00ff00; text-align: center; max-width: 90%;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }
        
        .setup-box h1 { margin-bottom: 20px; font-size: 24px; }
        .setup-box input {
            width: 100%; padding: 12px; margin: 10px 0;
            background: #333; border: 2px solid #00ff00; color: #00ff00;
            border-radius: 8px; font-size: 16px;
        }
        
        .setup-box button {
            padding: 15px 30px; background: #00ff00; color: #000;
            border: none; border-radius: 8px; cursor: pointer;
            font-weight: bold; font-size: 16px; margin-top: 15px;
        }
        
        .firebase-info {
            background: #2a2a00; padding: 15px; border-radius: 8px;
            margin: 15px 0; font-size: 12px; text-align: left;
        }
        
        #map { width: 100%; height: 100vh; filter: brightness(0.9); }
        
        .hud {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1000;
        }
        
        .status {
            position: absolute; top: 15px; left: 15px;
            background: rgba(0, 0, 0, 0.9); padding: 12px; border-radius: 8px;
            border: 2px solid #00ff00; pointer-events: auto; font-size: 11px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }
        
        .layers {
            position: absolute; top: 15px; right: 15px;
            background: rgba(0, 0, 0, 0.9); border: 2px solid #00ff00;
            border-radius: 8px; padding: 8px; pointer-events: auto;
        }
        
        .layer-btn {
            display: block; width: 70px; margin: 3px 0; padding: 6px;
            background: rgba(0, 0, 0, 0.8); border: 1px solid #00ff00;
            color: #00ff00; border-radius: 4px; cursor: pointer; font-size: 10px;
            text-align: center;
        }
        
        .layer-btn.active { background: rgba(0, 255, 0, 0.3); }
        
        .controls-bottom {
            position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; pointer-events: auto;
        }
        
        .btn {
            padding: 10px 15px; background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00; color: #00ff00; border-radius: 6px;
            cursor: pointer; font-weight: bold; font-size: 11px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
        
        .btn:hover { background: rgba(0, 255, 0, 0.2); }
        .btn.active { background: rgba(255, 0, 0, 0.8); border-color: #ff0000; color: #fff; }
        
        .draw-panel {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9); border: 2px solid #00ff00;
            border-radius: 8px; padding: 10px; pointer-events: auto;
            display: none; box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }
        
        .draw-panel.show { display: flex; gap: 8px; align-items: center; }
        
        .color-picker { display: flex; gap: 4px; margin: 0 8px; }
        .color { 
            width: 16px; height: 16px; border-radius: 50%;
            border: 2px solid #fff; cursor: pointer;
        }
        .color.active { border-color: #00ff00; box-shadow: 0 0 8px currentColor; }
        
        .hidden { display: none !important; }
        
        .loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9); padding: 20px; border-radius: 8px;
            border: 2px solid #00ff00; z-index: 9999; text-align: center;
        }
        
        .notification {
            position: fixed; top: 20px; right: 20px; z-index: 2000;
            background: rgba(0, 255, 0, 0.9); color: #000; padding: 10px 20px;
            border-radius: 20px; font-weight: bold; font-size: 12px;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="setup-screen" id="setupScreen">
        <div class="setup-box">
            <h1>üéØ AIRSOFT TACTICAL</h1>
            
            <div class="firebase-info">
                <strong>Firebase requis :</strong><br>
                1. <a href="https://console.firebase.google.com" target="_blank" style="color: #00ff00;">console.firebase.google.com</a><br>
                2. Cr√©er projet ‚Üí Realtime Database<br>
                3. R√®gles ‚Üí Mode test (30 jours)
            </div>
            
            <input type="text" id="firebaseUrl" placeholder="URL Firebase" 
                   value="https://airsoft-tactical-default-rtdb.europe-west1.firebasedatabase.app/">
            <input type="text" id="teamCode" placeholder="Code √©quipe (ex: ALPHA)" maxlength="15">
            <input type="text" id="playerName" placeholder="Votre indicatif (ex: LEADER)" maxlength="10">
            
            <button onclick="startApp()">üöÄ D√âMARRER MISSION</button>
        </div>
    </div>

    <div class="loading hidden" id="loadingScreen">
        <div>üîÑ Connexion Firebase...</div>
        <div id="loadingStatus" style="font-size: 12px; margin-top: 10px;">Initialisation</div>
    </div>

    <div id="map" class="hidden"></div>

    <div class="hud hidden" id="gameHUD">
        <div class="status">
            <div style="font-weight: bold; margin-bottom: 8px;">üéØ STATUS</div>
            <div id="firebaseStatus">üî• Firebase: ‚ùå</div>
            <div id="gpsStatus">üìç GPS: ‚ùå</div>
            <div id="teamStatus">üë• √âquipe: 0</div>
        </div>

        <div class="layers">
            <div style="font-size: 10px; font-weight: bold; margin-bottom: 5px; text-align: center;">CARTES</div>
            <button class="layer-btn active" onclick="switchLayer('osm')" id="osmBtn">Standard</button>
            <button class="layer-btn" onclick="switchLayer('satellite')" id="satelliteBtn">Satellite</button>
            <button class="layer-btn" onclick="switchLayer('topo')" id="topoBtn">Topo</button>
            <button class="layer-btn" onclick="switchLayer('tactical')" id="tacticalBtn">Tactique</button>
        </div>

        <div class="controls-bottom">
            <button class="btn" onclick="centerPlayer()">üìç CENTRER</button>
            <button class="btn" onclick="testLayers()">üîç TEST</button>
            <button class="btn" id="enemyBtn" onclick="toggleEnemy()">üéØ ENNEMI</button>
            <button class="btn" id="drawBtn" onclick="toggleDraw()">‚úèÔ∏è DESSIN</button>
            <button class="btn" onclick="showSetup()">‚öôÔ∏è CONFIG</button>
        </div>

        <div class="draw-panel" id="drawPanel">
            <span style="font-size: 10px; font-weight: bold;">DESSIN:</span>
            <button class="btn" onclick="setDrawMode('rectangle')" style="padding: 4px 8px; font-size: 10px;">RECT</button>
            <button class="btn" onclick="setDrawMode('circle')" style="padding: 4px 8px; font-size: 10px;">CERCLE</button>
            <div class="color-picker">
                <div class="color active" style="background: #ff4444;" onclick="setColor('#ff4444')"></div>
                <div class="color" style="background: #ffaa00;" onclick="setColor('#ffaa00')"></div>
                <div class="color" style="background: #00ff00;" onclick="setColor('#00ff00')"></div>
                <div class="color" style="background: #0080ff;" onclick="setColor('#0080ff')"></div>
            </div>
            <button class="btn" onclick="clearObstacles()" style="padding: 4px 8px; font-size: 10px;">CLEAR</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-database-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

    <script>
        // Variables globales
        let map, layers = {}, playerMarker, teammateMarkers = {};
        let obstacleGroup, database, teamRef, obstacleRef;
        let currentPosition, watchId, isConnected = false;
        let enemyMode = false, drawMode = false, currentDrawMode = 'rectangle', currentColor = '#ff4444';
        let teamCode, playerName, firebaseUrl;

        // Fonction principale
        function startApp() {
            firebaseUrl = document.getElementById('firebaseUrl').value.trim();
            teamCode = document.getElementById('teamCode').value.trim().toUpperCase();
            playerName = document.getElementById('playerName').value.trim().toUpperCase();

            if (!firebaseUrl || !teamCode || !playerName) {
                alert('Veuillez remplir tous les champs');
                return;
            }

            localStorage.setItem('airsoftConfig', JSON.stringify({firebaseUrl, teamCode, playerName}));

            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('loadingScreen').classList.remove('hidden');

            initFirebase();
        }

        function initFirebase() {
            updateLoading('Connexion Firebase...');
            
            try {
                const config = { databaseURL: firebaseUrl };
                
                if (firebase.apps.length === 0) {
                    firebase.initializeApp(config);
                }
                
                database = firebase.database();
                
                database.ref('.info/connected').on('value', (snapshot) => {
                    isConnected = snapshot.val();
                    updateStatus('firebaseStatus', isConnected ? 'üî• Firebase: ‚úÖ' : 'üî• Firebase: ‚ùå');
                    
                    if (isConnected && !teamRef) {
                        setupTeam();
                    }
                });
                
            } catch (error) {
                console.error('Erreur Firebase:', error);
                alert('Erreur Firebase: ' + error.message);
                showSetup();
            }
        }

        function setupTeam() {
            updateLoading('Configuration √©quipe...');
            
            teamRef = database.ref(`teams/${teamCode}`);
            obstacleRef = database.ref(`obstacles/${teamCode}`);
            
            teamRef.on('value', updateTeam);
            obstacleRef.on('value', updateObstacles);
            
            teamRef.on('child_added', (snapshot) => {
                const id = snapshot.key;
                if (id !== playerName) notify(`${id} rejoint l'√©quipe`);
            });
            
            teamRef.on('child_removed', (snapshot) => {
                const id = snapshot.key;
                if (teammateMarkers[id]) {
                    map.removeLayer(teammateMarkers[id]);
                    delete teammateMarkers[id];
                    notify(`${id} quitte l'√©quipe`);
                }
            });
            
            initMap();
        }

        function initMap() {
            updateLoading('Chargement carte...');
            
            map = L.map('map', {
                center: [48.8566, 2.3522],
                zoom: 15,
                zoomControl: false,
                attributionControl: false,
                preferCanvas: true
            });

            // Couche Standard OpenStreetMap (fiable)
            layers.osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '',
                crossOrigin: true
            });
            
            // Couche Satellite alternative plus fiable
            layers.satellite = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                maxZoom: 20,
                attribution: '',
                crossOrigin: true
            });
            
            // Couche Topo alternative
            layers.topo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                maxZoom: 17,
                attribution: '',
                crossOrigin: true
            });
            
            // Couche tactique simplifi√©e en Canvas
            layers.tactical = L.gridLayer({
                maxZoom: 20,
                attribution: ''
            });
            
            // Cr√©er la grille tactique
            layers.tactical.createTile = function(coords) {
                const tile = document.createElement('canvas');
                const ctx = tile.getContext('2d');
                tile.width = tile.height = 256;
                
                // Fond noir
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, 256, 256);
                
                // Grille verte
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.6;
                
                const gridSize = 32;
                for (let x = 0; x <= 256; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, 256);
                    ctx.stroke();
                }
                for (let y = 0; y <= 256; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(256, y);
                    ctx.stroke();
                }
                
                return tile;
            };

            // Ajouter la couche par d√©faut avec gestion d'erreur
            layers.osm.on('tileerror', function(error) {
                console.warn('Erreur de chargement tuile OSM:', error);
                notify('Connexion lente - Chargement en cours...');
            });
            
            layers.osm.on('tileload', function() {
                console.log('Tuile OSM charg√©e avec succ√®s');
            });

            map.addLayer(layers.osm);

            // Groupe d'obstacles
            obstacleGroup = L.layerGroup().addTo(map);
            
            // √âv√©nements
            map.on('click', onMapClick);
            
            // √âv√©nement de chargement de la carte
            map.whenReady(function() {
                console.log('Carte pr√™te');
                notify('Carte charg√©e');
            });

            // Test de connectivit√© apr√®s 3 secondes
            setTimeout(testMapLayers, 3000);

            startGPS();
        }
        
        function testMapLayers() {
            console.log('=== TEST DES COUCHES ===');
            console.log('Couches disponibles:', Object.keys(layers));
            console.log('OSM charg√©e:', map.hasLayer(layers.osm));
            
            // Forcer un rafra√Æchissement si aucune tuile n'est visible
            const mapContainer = document.getElementById('map');
            const tiles = mapContainer.querySelectorAll('.leaflet-tile');
            console.log('Nombre de tuiles:', tiles.length);
            
            if (tiles.length === 0) {
                console.warn('Aucune tuile charg√©e, tentative de rafra√Æchissement...');
                map.invalidateSize();
                map.setView([48.8566, 2.3522], 15);
                notify('Rafra√Æchissement de la carte...');
            }
        }

        function startGPS() {
            updateLoading('Activation GPS...');
            
            if (!navigator.geolocation) {
                alert('GPS non support√©');
                return;
            }

            const options = { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 };
            
            navigator.geolocation.getCurrentPosition(onGPS, onGPSError, options);
            watchId = navigator.geolocation.watchPosition(onGPS, onGPSError, options);
        }

        function onGPS(position) {
            currentPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: Math.round(position.coords.accuracy),
                timestamp: Date.now()
            };

            updateStatus('gpsStatus', 'üìç GPS: ‚úÖ');
            updatePlayerMarker();
            sharePosition();

            if (document.getElementById('map').classList.contains('hidden')) {
                document.getElementById('loadingScreen').classList.add('hidden');
                document.getElementById('map').classList.remove('hidden');
                document.getElementById('gameHUD').classList.remove('hidden');
                centerPlayer();
            }
        }

        function onGPSError(error) {
            updateStatus('gpsStatus', 'üìç GPS: ‚ùå');
            
            currentPosition = {
                lat: 48.8566 + (Math.random() - 0.5) * 0.01,
                lng: 2.3522 + (Math.random() - 0.5) * 0.01,
                accuracy: 999,
                timestamp: Date.now()
            };
            
            updatePlayerMarker();
            sharePosition();
            
            document.getElementById('loadingScreen').classList.add('hidden');
            document.getElementById('map').classList.remove('hidden');
            document.getElementById('gameHUD').classList.remove('hidden');
            
            notify('GPS indisponible - Mode d√©mo');
        }

        function updatePlayerMarker() {
            if (!map || !currentPosition) return;
            
            if (playerMarker) map.removeLayer(playerMarker);
            
            const icon = L.divIcon({
                className: '',
                html: `<div style="width: 20px; height: 20px; background: #ff0000; border: 3px solid #fff; border-radius: 50%; box-shadow: 0 0 15px #ff0000;"></div>`,
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            
            playerMarker = L.marker([currentPosition.lat, currentPosition.lng], {icon}).addTo(map);
            playerMarker.bindPopup(`<b>${playerName}</b><br>√âquipe: ${teamCode}<br>Pr√©cision: ${currentPosition.accuracy}m`);
        }

        function sharePosition() {
            if (!teamRef || !currentPosition) return;
            
            teamRef.child(playerName).set({
                lat: currentPosition.lat,
                lng: currentPosition.lng,
                accuracy: currentPosition.accuracy,
                timestamp: currentPosition.timestamp,
                lastSeen: Date.now()
            });
        }

        function updateTeam(snapshot) {
            const data = snapshot.val();
            if (!data) return;
            
            const members = Object.keys(data);
            updateStatus('teamStatus', `üë• √âquipe: ${members.length}`);
            
            members.forEach(id => {
                if (id === playerName) return;
                
                const member = data[id];
                if (!member.lat || !member.lng) return;
                
                let distance = 0;
                if (currentPosition) {
                    const R = 6371000;
                    const dLat = (member.lat - currentPosition.lat) * Math.PI / 180;
                    const dLng = (member.lng - currentPosition.lng) * Math.PI / 180;
                    const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(currentPosition.lat * Math.PI / 180) * Math.cos(member.lat * Math.PI / 180) * Math.sin(dLng/2) * Math.sin(dLng/2);
                    distance = Math.round(R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)));
                }
                
                if (teammateMarkers[id]) map.removeLayer(teammateMarkers[id]);
                
                const icon = L.divIcon({
                    className: '',
                    html: `
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <div style="width: 16px; height: 16px; background: #00ff00; border: 2px solid #fff; border-radius: 50%; margin-bottom: 3px;"></div>
                            <div style="background: rgba(0,255,0,0.9); color: #000; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: bold; border: 1px solid #fff; white-space: nowrap;">
                                ${id} - ${distance}m
                            </div>
                        </div>
                    `,
                    iconSize: [80, 40],
                    iconAnchor: [40, 20]
                });
                
                teammateMarkers[id] = L.marker([member.lat, member.lng], {icon}).addTo(map);
                teammateMarkers[id].bindPopup(`<b>${id}</b><br>Distance: ${distance}m<br>Pr√©cision: ${member.accuracy}m`);
            });
        }

        function updateObstacles(snapshot) {
            const data = snapshot.val();
            obstacleGroup.clearLayers();
            
            if (!data) return;
            
            Object.keys(data).forEach(id => {
                const obs = data[id];
                let layer;
                
                try {
                    if (obs.type === 'rectangle') {
                        layer = L.rectangle(obs.bounds, {color: obs.color, weight: 3, fillOpacity: 0.3});
                    } else if (obs.type === 'circle') {
                        layer = L.circle(obs.center, {radius: obs.radius, color: obs.color, weight: 3, fillOpacity: 0.3});
                    }
                    
                    if (layer) {
                        layer._obstacleId = id;
                        layer.bindPopup(`<b>Obstacle ${obs.type}</b><br>Par: ${obs.createdBy}<br><button onclick="removeObstacle('${id}')" style="background: #ff4444; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer;">Supprimer</button>`);
                        obstacleGroup.addLayer(layer);
                    }
                } catch (error) {
                    console.error('Erreur obstacle:', error);
                }
            });
        }

        function switchLayer(type) {
            console.log(`Changement vers couche: ${type}`);
            
            // Supprimer toutes les couches existantes
            Object.keys(layers).forEach(layerName => {
                if (layers[layerName] && map.hasLayer(layers[layerName])) {
                    map.removeLayer(layers[layerName]);
                    console.log(`Couche ${layerName} supprim√©e`);
                }
            });
            
            // Ajouter la nouvelle couche
            if (layers[type]) {
                map.addLayer(layers[type]);
                console.log(`Couche ${type} ajout√©e`);
                
                // Mettre √† jour l'interface
                document.querySelectorAll('.layer-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(type + 'Btn').classList.add('active');
                
                // Gestion sp√©ciale pour la couche tactique
                if (type === 'tactical') {
                    // Forcer un redraw pour la couche canvas
                    setTimeout(() => {
                        map.invalidateSize();
                    }, 100);
                }
                
                notify(`Carte: ${type.toUpperCase()}`);
                
                // Test de chargement apr√®s 2 secondes
                setTimeout(() => {
                    const tiles = document.querySelectorAll('.leaflet-tile');
                    console.log(`Tuiles charg√©es pour ${type}:`, tiles.length);
                    if (tiles.length === 0 && type !== 'tactical') {
                        notify('Erreur de chargement - R√©essayez');
                    }
                }, 2000);
                
            } else {
                console.error('Couche non trouv√©e:', type);
                notify('Erreur: Couche non trouv√©e');
                
                // Fallback vers OSM
                if (type !== 'osm' && layers.osm) {
                    console.log('Fallback vers OSM');
                    map.addLayer(layers.osm);
                    document.getElementById('osmBtn').classList.add('active');
                }
            }
        }

        function centerPlayer() {
            if (currentPosition) {
                map.setView([currentPosition.lat, currentPosition.lng], 17, {animate: true});
            }
        }

        function toggleEnemy() {
            if (drawMode) toggleDraw();
            
            enemyMode = !enemyMode;
            const btn = document.getElementById('enemyBtn');
            
            if (enemyMode) {
                btn.classList.add('active');
                map.getContainer().style.cursor = 'crosshair';
                notify('Mode ennemi - Cliquez sur la carte');
            } else {
                btn.classList.remove('active');
                map.getContainer().style.cursor = '';
            }
        }

        function toggleDraw() {
            if (enemyMode) toggleEnemy();
            
            drawMode = !drawMode;
            const btn = document.getElementById('drawBtn');
            const panel = document.getElementById('drawPanel');
            
            if (drawMode) {
                btn.classList.add('active');
                panel.classList.add('show');
                map.getContainer().style.cursor = 'crosshair';
                notify('Mode dessin - S√©lectionnez un outil');
            } else {
                btn.classList.remove('active');
                panel.classList.remove('show');
                map.getContainer().style.cursor = '';
            }
        }

        function setDrawMode(mode) {
            currentDrawMode = mode;
            notify(`Outil: ${mode.toUpperCase()}`);
        }

        function setColor(color) {
            currentColor = color;
            document.querySelectorAll('.color').forEach(c => c.classList.remove('active'));
            event.target.classList.add('active');
        }

        function onMapClick(e) {
            if (enemyMode) {
                addEnemyMarker(e.latlng);
                toggleEnemy();
            } else if (drawMode) {
                const obstacleId = 'obs_' + Date.now();
                let obstacleData = {
                    type: currentDrawMode,
                    color: currentColor,
                    createdBy: playerName,
                    timestamp: Date.now()
                };

                if (currentDrawMode === 'circle') {
                    obstacleData.center = e.latlng;
                    obstacleData.radius = 50;
                } else {
                    const offset = 0.0005;
                    obstacleData.bounds = [
                        [e.latlng.lat - offset, e.latlng.lng - offset],
                        [e.latlng.lat + offset, e.latlng.lng + offset]
                    ];
                }

                if (obstacleRef) {
                    obstacleRef.child(obstacleId).set(obstacleData);
                }
                
                notify('Obstacle ajout√©');
                toggleDraw();
            }
        }

        function addEnemyMarker(latlng) {
            const icon = L.divIcon({
                className: '',
                html: '<div style="width: 16px; height: 16px; background: #ff4444; border: 2px solid #fff; transform: rotate(45deg); animation: blink 0.8s infinite alternate;"></div><style>@keyframes blink { 0% { opacity: 1; } 100% { opacity: 0.6; } }</style>',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
            
            const marker = L.marker([latlng.lat, latlng.lng], {icon}).addTo(map);
            marker.bindPopup(`‚ö†Ô∏è Ennemi signal√© par ${playerName}<br>Dispara√Æt dans 30s`);
            
            setTimeout(() => {
                if (map.hasLayer(marker)) map.removeLayer(marker);
            }, 30000);
            
            notify('Ennemi marqu√© !');
            
            if (navigator.vibrate) navigator.vibrate(200);
        }

        function clearObstacles() {
            if (confirm('Effacer tous les obstacles ?')) {
                if (obstacleRef) obstacleRef.remove();
                notify('Obstacles effac√©s');
            }
        }

        function removeObstacle(id) {
            if (obstacleRef) obstacleRef.child(id).remove();
            notify('Obstacle supprim√©');
        }

        function showSetup() {
            document.getElementById('setupScreen').classList.remove('hidden');
            document.getElementById('map').classList.add('hidden');
            document.getElementById('gameHUD').classList.add('hidden');
        }
        
        function testLayers() {
            console.log('=== TEST MANUEL DES COUCHES ===');
            Object.keys(layers).forEach(layerName => {
                console.log(`${layerName}:`, layers[layerName] ? 'OK' : 'ERREUR');
            });
            
            const tiles = document.querySelectorAll('.leaflet-tile');
            console.log('Tuiles visibles:', tiles.length);
            
            // Test de connectivit√©
            const testImg = new Image();
            testImg.onload = () => {
                notify('‚úÖ Connexion Internet OK');
                console.log('Test connectivit√©: OK');
            };
            testImg.onerror = () => {
                notify('‚ùå Probl√®me de connexion');
                console.log('Test connectivit√©: ERREUR');
            };
            testImg.src = 'https://tile.openstreetmap.org/10/512/357.png?' + Date.now();
            
            // Rafra√Æchir la carte
            map.invalidateSize();
            notify('Test des couches - Voir console (F12)');
        }

        function updateLoading(text) {
            document.getElementById('loadingStatus').textContent = text;
        }

        function updateStatus(id, text) {
            document.getElementById(id).textContent = text;
        }

        function notify(message) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            document.body.appendChild(notif);
            
            setTimeout(() => {
                if (document.body.contains(notif)) document.body.removeChild(notif);
            }, 3000);
        }

        // Fonction globale pour les popups
        window.removeObstacle = removeObstacle;

        // Charger config sauvegard√©e
        window.addEventListener('load', () => {
            const saved = localStorage.getItem('airsoftConfig');
            if (saved) {
                const config = JSON.parse(saved);
                document.getElementById('firebaseUrl').value = config.firebaseUrl || '';
                document.getElementById('teamCode').value = config.teamCode || '';
                document.getElementById('playerName').value = config.playerName || '';
            }
        });

        // Nettoyage
        window.addEventListener('beforeunload', () => {
            if (watchId) navigator.geolocation.clearWatch(watchId);
            if (teamRef && playerName) teamRef.child(playerName).remove();
        });

        // Partage position automatique
        setInterval(() => {
            if (currentPosition && isConnected) {
                sharePosition();
            }
        }, 5000);

        console.log('üöÄ Airsoft Tactical Pro - Version finale charg√©e');
    </script>
</body>
</html>