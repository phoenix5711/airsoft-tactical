<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Airsoft Tactical Pro</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icon-192.png">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #000; color: #00ff00; overflow: hidden; }
        
        .setup-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            z-index: 10000;
        }
        
        .setup-box {
            background: #1a1a1a; padding: 30px; border-radius: 15px;
            border: 2px solid #00ff00; text-align: center; max-width: 90%;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }
        
        .setup-box h1 { margin-bottom: 20px; font-size: 24px; }
        .setup-box input {
            width: 100%; padding: 12px; margin: 10px 0;
            background: #333; border: 2px solid #00ff00; color: #00ff00;
            border-radius: 8px; font-size: 16px;
        }
        
        .setup-box button {
            padding: 15px 30px; background: #00ff00; color: #000;
            border: none; border-radius: 8px; cursor: pointer;
            font-weight: bold; font-size: 16px; margin-top: 15px;
        }
        
        #map { width: 100%; height: 100vh; }
        
        .hud {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1000;
        }
        
        .status {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.8); padding: 8px; border-radius: 6px;
            border: 1px solid #00ff00; pointer-events: auto; font-size: 10px;
            display: flex; gap: 10px;
        }
        
        .status-item {
            display: flex; align-items: center; gap: 3px;
        }
        
        .layers {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.8); border: 1px solid #00ff00;
            border-radius: 6px; padding: 5px; pointer-events: auto;
            display: flex; gap: 5px;
        }
        
        .layer-btn {
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.8); border: 1px solid #00ff00;
            color: #00ff00; border-radius: 4px; cursor: pointer; font-size: 10px;
        }
        
        .layer-btn.active { background: rgba(0, 255, 0, 0.3); }
        
        .controls-bottom {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; pointer-events: auto;
            background: rgba(0, 0, 0, 0.8); padding: 8px; border-radius: 20px;
            border: 1px solid #00ff00;
        }
        
        .btn {
            padding: 8px 12px; background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff00; color: #00ff00; border-radius: 15px;
            cursor: pointer; font-weight: bold; font-size: 10px;
            transition: all 0.3s;
        }
        
        .btn:hover { background: rgba(0, 255, 0, 0.2); }
        .btn.active { background: rgba(255, 0, 0, 0.8); border-color: #ff0000; color: #fff; }
        
        .draw-panel {
            position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9); border: 1px solid #00ff00;
            border-radius: 15px; padding: 8px; pointer-events: auto;
            display: none;
        }
        
        .draw-panel.show { display: flex; gap: 5px; align-items: center; }
        
        .color-picker { display: flex; gap: 4px; margin: 0 5px; }
        .color { 
            width: 14px; height: 14px; border-radius: 50%;
            border: 1px solid #fff; cursor: pointer;
        }
        .color.active { border-color: #00ff00; box-shadow: 0 0 8px currentColor; }
        
        .hidden { display: none !important; }
        
        .loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9); padding: 20px; border-radius: 8px;
            border: 2px solid #00ff00; z-index: 9999; text-align: center;
        }
        
        .notification {
            position: fixed; top: 60px; right: 10px; z-index: 2000;
            background: rgba(0, 255, 0, 0.9); color: #000; padding: 8px 15px;
            border-radius: 15px; font-weight: bold; font-size: 11px;
            animation: slideIn 0.3s ease;
        }
        
        /* Marqueurs au-dessus des obstacles */
        .leaflet-marker-pane { z-index: 600 !important; }
        .leaflet-popup-pane { z-index: 700 !important; }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="setup-screen" id="setupScreen">
        <div class="setup-box">
            <h1>üéØ AIRSOFT TACTICAL</h1>
            
            <input type="text" id="teamCode" placeholder="Code √©quipe (ex: ALPHA)" maxlength="15">
            <input type="text" id="playerName" placeholder="Votre indicatif (ex: LEADER)" maxlength="10">
            
            <button onclick="startApp()">üöÄ D√âMARRER MISSION</button>
        </div>
    </div>

    <div class="loading hidden" id="loadingScreen">
        <div>üì° Connexion...</div>
        <div id="loadingStatus" style="font-size: 12px; margin-top: 10px;">Initialisation</div>
    </div>

    <div id="map" class="hidden"></div>

    <div class="hud hidden" id="gameHUD">
        <div class="status">
            <div class="status-item" id="firebaseStatus">üî•OFF</div>
            <div class="status-item" id="gpsStatus">üìçOFF</div>
            <div class="status-item" id="teamStatus">üë•0</div>
        </div>

        <div class="layers">
            <button class="layer-btn active" onclick="switchLayer('standard')" id="standardBtn">Standard</button>
            <button class="layer-btn" onclick="switchLayer('satellite')" id="satelliteBtn">Satellite</button>
            <button class="layer-btn" onclick="switchLayer('tactical')" id="tacticalBtn">Tactique</button>
        </div>

        <div class="controls-bottom">
            <button class="btn" onclick="centerPlayer()">üìç</button>
            <button class="btn" onclick="recalibrateGPS()" title="Recalibrer GPS">üîÑ</button>
            <button class="btn" id="enemyBtn" onclick="toggleEnemy()">üéØ</button>
            <button class="btn" id="drawBtn" onclick="toggleDraw()">‚úèÔ∏è</button>
            <button class="btn" id="configBtn" onclick="handleConfigClick()">üì≤</button>
        </div>

        <div class="draw-panel" id="drawPanel">
            <button class="btn active" onclick="setDrawMode('rectangle', event)" style="padding: 4px 8px;">‚ñ≠</button>
            <button class="btn" onclick="setDrawMode('circle', event)" style="padding: 4px 8px;">‚óã</button>
            <div class="color-picker">
                <div class="color active" style="background: #ff4444;" onclick="setColor('#ff4444', event)"></div>
                <div class="color" style="background: #ffaa00;" onclick="setColor('#ffaa00', event)"></div>
                <div class="color" style="background: #00ff00;" onclick="setColor('#00ff00', event)"></div>
                <div class="color" style="background: #0080ff;" onclick="setColor('#0080ff', event)"></div>
            </div>
        </div>
    </div>

    <div class="qr-modal" id="qrModal">
        <div class="qr-content">
            <h3>üì° PARTAGER L'√âQUIPE</h3>
            <div class="team-code">CODE: <span id="qrTeamCode"></span></div>
            <div class="qr-code-container">
                <img id="qrcode" alt="QR Code" style="width: 200px; height: 200px;">
            </div>
            <p style="font-size: 12px; color: #888;">Scannez pour rejoindre l'√©quipe</p>
            <button onclick="copyTeamLink()">üìã Copier le lien</button>
            <button onclick="installPWA()" id="installBtn" style="display: none;">üì• Installer l'app</button>
            <button class="close-btn" onclick="closeQRModal()">Fermer</button>
            <div style="margin-top: 15px;">
                <a href="#" onclick="changeTeam()" style="color: #888; font-size: 11px; text-decoration: underline;">Changer d'√©quipe</a>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
        // Import Firebase
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue, remove, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Variables globales
        let map, layers = {}, playerMarker, teammateMarkers = {};
        let obstacleGroup, database, teamRef, obstacleRef, enemyRef;
        let currentPosition, watchId, isConnected = false;
        let enemyMode = false, drawMode = false, currentDrawMode = 'rectangle', currentColor = '#ff4444';
        let teamCode, playerName;
        let isDrawing = false, drawStartPoint = null, previewLayer = null;
        let enemyMarkers = {};
        let gridLayer; // Pour le quadrillage tactique

        // Configuration Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyCVhcOgKGV5e_S8WZ6sNgT0qGXNhJDFQnY",
            authDomain: "airsoft-tactical.firebaseapp.com",
            databaseURL: "https://airsoft-tactical-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "airsoft-tactical",
            storageBucket: "airsoft-tactical.appspot.com",
            messagingSenderId: "123456789",
            appId: "1:123456789:web:abc123def456"
        };

        // Exposer les fonctions globalement
        window.startApp = startApp;
        window.switchLayer = switchLayer;
        window.centerPlayer = centerPlayer;
        window.toggleEnemy = toggleEnemy;
        window.toggleDraw = toggleDraw;
        window.setDrawMode = (mode, evt) => setDrawMode(mode, evt);
        window.setColor = (color, evt) => setColor(color, evt);
        window.showSetup = showSetup;
        window.removeObstacle = removeObstacle;
        window.updateGrid = updateGrid;
        window.showQRCode = showQRCode;
        window.closeQRModal = closeQRModal;
        window.copyTeamLink = copyTeamLink;
        window.recalibrateGPS = recalibrateGPS;
        window.changeTeam = changeTeam;
        
        function changeTeam() {
            if (confirm('Voulez-vous vraiment changer d\'√©quipe ? Vous serez d√©connect√© de l\'√©quipe actuelle.')) {
                // Nettoyer la connexion actuelle
                if (database && playerName && teamCode && isConnected) {
                    const playerRef = ref(database, `teams/${teamCode}/${playerName}`);
                    remove(playerRef);
                }
                
                // R√©initialiser les variables
                teamCode = null;
                playerName = null;
                
                // Fermer le QR modal
                closeQRModal();
                
                // Afficher l'√©cran de configuration
                document.getElementById('setupScreen').classList.remove('hidden');
                document.getElementById('map').classList.add('hidden');
                document.getElementById('gameHUD').classList.add('hidden');
            }
        }
        
        function recalibrateGPS() {
            notify('Recalibrage GPS...');
            
            // Diagnostic GPS d√©taill√©
            const diagnosticInfo = [];
            
            // V√©rifier le support GPS
            if (!navigator.geolocation) {
                alert('GPS NON SUPPORT√â sur ce navigateur!');
                return;
            }
            
            // Arr√™ter l'ancien watchPosition
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            // Test avec diff√©rentes configurations
            notify('Test 1/3: Position rapide...');
            
            // Test 1: Position rapide
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    diagnosticInfo.push(`Rapide OK: ${Math.round(pos.coords.accuracy)}m`);
                    notify('Test 2/3: Haute pr√©cision...');
                    
                    // Test 2: Haute pr√©cision
                    navigator.geolocation.getCurrentPosition(
                        (pos2) => {
                            diagnosticInfo.push(`Pr√©cis OK: ${Math.round(pos2.coords.accuracy)}m`);
                            
                            if (pos2.coords.accuracy > 500) {
                                alert(`DIAGNOSTIC GPS:\n\n${diagnosticInfo.join('\n')}\n\nPROBL√àME D√âTECT√â!\nPr√©cision: ${Math.round(pos2.coords.accuracy)}m\n\n` +
                                    `SOLUTIONS:\n` +
                                    `1. Param√®tres ‚Üí Position ‚Üí Mode\n` +
                                    `   ‚ûú S√©lectionnez "Haute pr√©cision"\n\n` +
                                    `2. Param√®tres ‚Üí Apps ‚Üí Navigateur\n` +
                                    `   ‚ûú Permissions ‚Üí Position: Autoriser\n\n` +
                                    `3. Allez EN EXT√âRIEUR (important!)\n\n` +
                                    `4. D√©sactivez l'√©conomie de batterie\n\n` +
                                    `5. Red√©marrez le t√©l√©phone si n√©cessaire`);
                            } else {
                                notify(`GPS OK (${Math.round(pos2.coords.accuracy)}m)`);
                                onGPS(pos2);
                            }
                            
                            // Relancer le suivi
                            watchId = navigator.geolocation.watchPosition(onGPS, onGPSError, {
                                enableHighAccuracy: true,
                                maximumAge: 1000,
                                timeout: 20000
                            });
                        },
                        (err) => {
                            diagnosticInfo.push(`Pr√©cis ERREUR: ${err.message}`);
                            alert(`DIAGNOSTIC GPS:\n\n${diagnosticInfo.join('\n')}\n\nERREUR: ${err.message}`);
                        },
                        { enableHighAccuracy: true, maximumAge: 0, timeout: 30000 }
                    );
                },
                (err) => {
                    diagnosticInfo.push(`Rapide ERREUR: ${err.message}`);
                    
                    if (err.code === 1) {
                        alert('GPS BLOQU√â!\n\nAutorisez la position dans les param√®tres du navigateur ET du t√©l√©phone');
                    } else {
                        alert(`ERREUR GPS: ${err.message}\n\nV√©rifiez vos param√®tres de localisation`);
                    }
                },
                { enableHighAccuracy: false, timeout: 5000 }
            );
            
            if (navigator.vibrate) navigator.vibrate(100);
        }
        
        let qrCodeInstance = null;
        
        function showQRCode() {
            if (!teamCode) {
                notify('Aucune √©quipe active');
                return;
            }
            
            const modal = document.getElementById('qrModal');
            const qrContainer = document.getElementById('qrcode');
            const teamCodeSpan = document.getElementById('qrTeamCode');
            
            // Afficher le code de l'√©quipe
            teamCodeSpan.textContent = teamCode;
            
            // G√©n√©rer l'URL avec le param√®tre team
            const shareUrl = `${window.location.origin}${window.location.pathname}?team=${encodeURIComponent(teamCode)}`;
            
            // Effacer l'ancien QR code s'il existe
            if (qrCodeInstance) {
                qrContainer.innerHTML = '';
                qrCodeInstance = null;
            }
            
            // G√©n√©rer le nouveau QR code
            qrCodeInstance = new QRCode(qrContainer, {
                text: shareUrl,
                width: 200,
                height: 200,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
            
            // Afficher la modal
            modal.style.display = 'flex';
            
            notify('QR Code g√©n√©r√©');
        }
        
        function closeQRModal() {
            document.getElementById('qrModal').style.display = 'none';
        }
        
        function copyTeamLink() {
            const shareUrl = `${window.location.origin}${window.location.pathname}?team=${encodeURIComponent(teamCode)}`;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(shareUrl).then(() => {
                    notify('Lien copi√© ! üìã');
                }).catch(() => {
                    fallbackCopyText(shareUrl);
                });
            } else {
                fallbackCopyText(shareUrl);
            }
        }
        
        function fallbackCopyText(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.top = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                notify('Lien copi√© !');
            } catch (err) {
                notify('Erreur - Copiez manuellement');
                console.error('Erreur copie:', err);
            }
            document.body.removeChild(textArea);
        }

        function startApp() {
            teamCode = document.getElementById('teamCode').value.trim().toUpperCase();
            playerName = document.getElementById('playerName').value.trim().toUpperCase();

            if (!teamCode || !playerName) {
                alert('Veuillez remplir tous les champs');
                return;
            }

            localStorage.setItem('airsoftConfig', JSON.stringify({teamCode, playerName}));

            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('loadingScreen').classList.remove('hidden');

            initFirebase();
        }

        function initFirebase() {
            updateLoading('Connexion...');
            
            try {
                const app = initializeApp(firebaseConfig);
                database = getDatabase(app);
                
                const connectedRef = ref(database, '.info/connected');
                onValue(connectedRef, (snapshot) => {
                    isConnected = snapshot.val() === true;
                    updateStatus('firebaseStatus', isConnected ? 'üî•ON' : 'üî•OFF');
                    
                    if (isConnected && !teamRef) {
                        setupTeam();
                    }
                });
                
            } catch (error) {
                console.error('Erreur Firebase:', error);
                setupOfflineMode();
            }
        }

        function setupTeam() {
            updateLoading('Configuration √©quipe...');
            
            try {
                // Cr√©er les r√©f√©rences Firebase seulement si connect√©
                if (database && isConnected) {
                    teamRef = ref(database, `teams/${teamCode}`);
                    obstacleRef = ref(database, `obstacles/${teamCode}`);
                    enemyRef = ref(database, `enemies/${teamCode}`);
                    
                    const playerRef = ref(database, `teams/${teamCode}/${playerName}`);
                    
                    // Configuration de la d√©connexion automatique
                    onDisconnect(playerRef).remove().catch(err => {
                        console.warn('Erreur onDisconnect:', err);
                    });
                    
                    // √âcoute des changements avec gestion d'erreur
                    onValue(teamRef, updateTeam, (error) => {
                        console.error('Erreur lecture √©quipe:', error);
                    });
                    
                    onValue(obstacleRef, updateObstacles, (error) => {
                        console.error('Erreur lecture obstacles:', error);
                    });
                    
                    onValue(enemyRef, updateEnemies, (error) => {
                        console.error('Erreur lecture ennemis:', error);
                    });
                    
                    console.log('Firebase configur√© pour √©quipe:', teamCode);
                }
                
                // Continuer avec l'initialisation de la carte
                // Ne pas attendre Firebase
                setTimeout(() => {
                    initMap();
                }, 500);
                
            } catch (error) {
                console.error('Erreur setupTeam:', error);
                updateLoading('Mode hors ligne...');
                setTimeout(() => {
                    initMap();
                }, 1000);
            }
        }

        function setupOfflineMode() {
            updateLoading('Mode hors ligne activ√©...');
            console.log('Passage en mode hors ligne');
            isConnected = false;
            updateStatus('firebaseStatus', 'üî•OFF');
            
            // Attendre un peu avant d'initialiser la carte
            setTimeout(() => {
                initMap();
                notify('‚ö†Ô∏è Mode hors ligne - Pas de partage √©quipe');
            }, 500);
        }

        function initMap() {
            updateLoading('Chargement carte...');
            
            map = L.map('map', {
                center: [48.8566, 2.3522],
                zoom: 15,
                zoomControl: false,
                attributionControl: false
            });

            // Couche Standard (OpenStreetMap)
            layers.standard = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19
            });

            // Couche Satellite (ESRI)
            layers.satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 19
            });

            // Couche Tactique avec quadrillage
            layers.tactical = L.layerGroup([
                L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                    maxZoom: 19,
                    opacity: 0.8
                })
            ]);
            
            // Cr√©er le layer pour le quadrillage
            gridLayer = L.layerGroup();
            layers.tactical.addLayer(gridLayer);
            
            // Mettre √† jour le quadrillage lors du d√©placement
            map.on('moveend zoomend', () => {
                if (map.hasLayer(layers.tactical)) {
                    updateGrid();
                }
            });

            // Ajouter la couche standard par d√©faut
            layers.standard.addTo(map);

            // Groupe d'obstacles
            obstacleGroup = L.layerGroup().addTo(map);
            
            // √âv√©nements
            map.on('click', onMapClick);
            map.on('mousemove', onMouseMove);
            
            startGPS();
        }
        
        function updateGrid() {
            if (!gridLayer) return;
            gridLayer.clearLayers();
            
            const bounds = map.getBounds();
            const zoom = map.getZoom();
            const gridSize = 0.0005 * Math.pow(2, 15 - zoom); // Taille adaptative selon zoom
            
            // Lignes verticales
            for (let lng = Math.floor(bounds.getWest() / gridSize) * gridSize; lng < bounds.getEast(); lng += gridSize) {
                const line = L.polyline([
                    [bounds.getSouth(), lng],
                    [bounds.getNorth(), lng]
                ], {
                    color: '#00ff00',
                    weight: 0.5,
                    opacity: 0.4
                });
                gridLayer.addLayer(line);
            }
            
            // Lignes horizontales
            for (let lat = Math.floor(bounds.getSouth() / gridSize) * gridSize; lat < bounds.getNorth(); lat += gridSize) {
                const line = L.polyline([
                    [lat, bounds.getWest()],
                    [lat, bounds.getEast()]
                ], {
                    color: '#00ff00',
                    weight: 0.5,
                    opacity: 0.4
                });
                gridLayer.addLayer(line);
            }
        }

        function startGPS() {
            updateLoading('Activation GPS...');
            
            if (!navigator.geolocation) {
                onGPSError();
                return;
            }

            // V√©rifier les permissions
            if (navigator.permissions) {
                navigator.permissions.query({name: 'geolocation'}).then(result => {
                    console.log('Permission GPS:', result.state);
                    if (result.state === 'denied') {
                        alert('GPS BLOQU√â !\n\nActivez la g√©olocalisation dans :\nParam√®tres ‚Üí Apps ‚Üí Navigateur ‚Üí Permissions ‚Üí Position\n\nOu dans les param√®tres de votre t√©l√©phone.');
                    }
                });
            }

            const options = { 
                enableHighAccuracy: true, 
                maximumAge: 0,      // Forcer position fra√Æche
                timeout: 30000      // 30 secondes de timeout
            };
            
            // Tentative directe haute pr√©cision
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log('GPS OK - Pr√©cision:', position.coords.accuracy);
                    onGPS(position);
                    
                    // Lancer le suivi continu
                    watchId = navigator.geolocation.watchPosition(onGPS, onGPSError, {
                        enableHighAccuracy: true,
                        maximumAge: 2000,
                        timeout: 20000
                    });
                },
                (error) => {
                    console.error('Erreur GPS:', error.code, error.message);
                    
                    if (error.code === 1) {
                        alert('GPS REFUS√â !\n\nAutorisez la localisation pour cette application.');
                    } else if (error.code === 3) {
                        notify('GPS timeout - Allez en ext√©rieur');
                    }
                    
                    // Mode d√©mo si erreur
                    onGPSError(error);
                },
                options
            );
        }

        function onGPS(position) {
            // Validation des coordonn√©es
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            
            console.log(`GPS: Lat=${lat}, Lng=${lng}, Pr√©cision=${accuracy}m`);
            
            // Rejeter les positions avec pr√©cision > 500m
            if (accuracy > 500) {
                console.warn(`Pr√©cision GPS trop faible: ${accuracy}m`);
                updateStatus('gpsStatus', `üìç‚ùå${Math.round(accuracy)}m`);
                
                // Si pr√©cision > 1000m, c'est probablement un probl√®me de configuration
                if (accuracy > 1000) {
                    notify('‚ö†Ô∏è GPS impr√©cis - V√©rifiez param√®tres');
                    alert(`PROBL√àME GPS D√âTECT√â !\nPr√©cision: ${Math.round(accuracy)}m\n\nSolutions:\n1. Allez en EXT√âRIEUR\n2. Activez "Haute pr√©cision" dans:\n   Param√®tres ‚Üí Position ‚Üí Mode\n3. D√©sactivez l'√©conomie de batterie\n4. Autorisez le GPS pour le navigateur`);
                }
                return; // Ne pas utiliser cette position
            }
            
            // V√©rifier si les coordonn√©es sont valides
            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                console.error('Coordonn√©es GPS invalides:', lat, lng);
                return;
            }
            
            updateStatus('gpsStatus', accuracy < 50 ? 'üìç‚úÖ' : `üìç${Math.round(accuracy)}m`);
            
            currentPosition = {
                lat: lat,
                lng: lng,
                accuracy: Math.round(accuracy),
                timestamp: Date.now()
            };

            updatePlayerMarker();
            sharePosition();

            if (document.getElementById('map').classList.contains('hidden')) {
                showMap();
            }
        }

        function onGPSError(error) {
            console.error('Erreur GPS:', error.code, error.message);
            updateStatus('gpsStatus', 'üìçERR');
            
            // Position de d√©mo uniquement si premi√®re tentative
            if (!currentPosition) {
                currentPosition = {
                    lat: 48.8566 + (Math.random() - 0.5) * 0.01,
                    lng: 2.3522 + (Math.random() - 0.5) * 0.01,
                    accuracy: 999,
                    timestamp: Date.now()
                };
                
                updatePlayerMarker();
                showMap();
                notify('GPS indisponible - Position d√©mo');
            }
        }

        function showMap() {
            document.getElementById('loadingScreen').classList.add('hidden');
            document.getElementById('map').classList.remove('hidden');
            document.getElementById('gameHUD').classList.remove('hidden');
            centerPlayer();
            map.invalidateSize();
        }

        function updatePlayerMarker() {
            if (!map || !currentPosition) return;
            
            if (playerMarker) map.removeLayer(playerMarker);
            
            const icon = L.divIcon({
                className: '',
                html: `<div style="width: 20px; height: 20px; background: #0080ff; border: 3px solid #fff; border-radius: 50%; box-shadow: 0 0 15px #0080ff;"></div>`,
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            
            playerMarker = L.marker([currentPosition.lat, currentPosition.lng], {icon, zIndexOffset: 1000}).addTo(map);
            playerMarker.bindPopup(`<b>${playerName}</b><br>√âquipe: ${teamCode}`);
        }

        function sharePosition() {
            if (!database || !currentPosition || !isConnected) return;
            
            const playerRef = ref(database, `teams/${teamCode}/${playerName}`);
            set(playerRef, {
                lat: currentPosition.lat,
                lng: currentPosition.lng,
                accuracy: currentPosition.accuracy,
                timestamp: currentPosition.timestamp
            });
        }

        function updateTeam(snapshot) {
            const data = snapshot.val();
            if (!data) return;
            
            const members = Object.keys(data);
            updateStatus('teamStatus', `üë•${members.length}`);
            
            members.forEach(id => {
                if (id === playerName) return;
                
                const member = data[id];
                if (!member.lat || !member.lng) return;
                
                if (teammateMarkers[id]) map.removeLayer(teammateMarkers[id]);
                
                const icon = L.divIcon({
                    className: '',
                    html: `
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <div style="width: 16px; height: 16px; background: #00ff00; border: 2px solid #fff; border-radius: 50%;"></div>
                            <div style="background: rgba(0,0,0,0.7); color: #00ff00; padding: 2px 4px; border-radius: 8px; font-size: 9px; font-weight: bold; margin-top: 2px;">
                                ${id}
                            </div>
                        </div>
                    `,
                    iconSize: [50, 30],
                    iconAnchor: [25, 15]
                });
                
                teammateMarkers[id] = L.marker([member.lat, member.lng], {icon}).addTo(map);
            });
        }

        function updateObstacles(snapshot) {
            const data = snapshot.val();
            obstacleGroup.clearLayers();
            
            if (!data) return;
            
            Object.keys(data).forEach(id => {
                const obs = data[id];
                let layer;
                
                if (obs.type === 'rectangle' && obs.bounds) {
                    layer = L.rectangle([
                        [obs.bounds.south, obs.bounds.west],
                        [obs.bounds.north, obs.bounds.east]
                    ], {
                        color: obs.color || '#ff4444',
                        weight: 2,
                        fillOpacity: 0.3,
                        interactive: !enemyMode  // Respecter le mode ennemi
                    });
                } else if (obs.type === 'circle' && obs.center && obs.radius) {
                    layer = L.circle([obs.center.lat, obs.center.lng], {
                        radius: obs.radius,
                        color: obs.color || '#ff4444',
                        weight: 2,
                        fillOpacity: 0.3,
                        interactive: !enemyMode  // Respecter le mode ennemi
                    });
                }
                
                if (layer) {
                    layer._obstacleId = id;
                    layer.bindPopup(`
                        <b>${obs.type}</b><br>
                        Par: ${obs.createdBy}<br>
                        <button onclick="removeObstacle('${id}')" style="background: #ff4444; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer;">
                            Supprimer
                        </button>
                    `);
                    obstacleGroup.addLayer(layer);
                }
            });
        }

        function switchLayer(type) {
            Object.keys(layers).forEach(layerName => {
                if (map.hasLayer(layers[layerName])) {
                    map.removeLayer(layers[layerName]);
                    if (layerName === 'tactical' && gridLayer) {
                        gridLayer.clearLayers();
                    }
                }
            });
            
            if (layers[type]) {
                layers[type].addTo(map);
                document.querySelectorAll('.layer-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(type + 'Btn').classList.add('active');
                
                // Si c'est la carte tactique, cr√©er le quadrillage
                if (type === 'tactical') {
                    updateGrid();
                }
                
                notify(`Carte: ${type}`);
            }
        }

        function centerPlayer() {
            if (currentPosition) {
                map.setView([currentPosition.lat, currentPosition.lng], 17, {animate: true});
                notify('Position centr√©e');
            }
        }

        function toggleEnemy() {
            if (drawMode) toggleDraw();
            
            enemyMode = !enemyMode;
            const btn = document.getElementById('enemyBtn');
            
            if (enemyMode) {
                btn.classList.add('active');
                map.getContainer().style.cursor = 'crosshair';
                
                // D√©sactiver l'interactivit√© des obstacles en mode ennemi
                obstacleGroup.eachLayer(layer => {
                    if (layer.options) {
                        layer.options.interactive = false;
                        layer.off('click');
                    }
                });
                
                notify('Mode ennemi - Cliquez n\'importe o√π');
            } else {
                btn.classList.remove('active');
                map.getContainer().style.cursor = '';
                
                // R√©activer l'interactivit√© des obstacles
                obstacleGroup.eachLayer(layer => {
                    if (layer.options) {
                        layer.options.interactive = true;
                    }
                });
            }
        }

        function toggleDraw() {
            if (enemyMode) toggleEnemy();
            
            drawMode = !drawMode;
            const btn = document.getElementById('drawBtn');
            const panel = document.getElementById('drawPanel');
            
            if (drawMode) {
                btn.classList.add('active');
                panel.classList.add('show');
                map.getContainer().style.cursor = 'crosshair';
                notify('Mode dessin activ√©');
            } else {
                btn.classList.remove('active');
                panel.classList.remove('show');
                map.getContainer().style.cursor = '';
                cancelDrawing();
            }
        }

        function setDrawMode(mode, evt) {
            currentDrawMode = mode;
            cancelDrawing();
            
            document.querySelectorAll('#drawPanel .btn').forEach(btn => btn.classList.remove('active'));
            if (evt && evt.target) {
                evt.target.classList.add('active');
            }
            notify(`Mode: ${mode === 'rectangle' ? 'Rectangle' : 'Cercle'}`);
        }

        function setColor(color, evt) {
            currentColor = color;
            document.querySelectorAll('.color').forEach(c => c.classList.remove('active'));
            if (evt && evt.target) {
                evt.target.classList.add('active');
            }
        }

        function onMapClick(e) {
            if (enemyMode) {
                addEnemyMarker(e.latlng);
                toggleEnemy();
            } else if (drawMode) {
                if (!isDrawing) {
                    startDrawing(e.latlng);
                } else {
                    finishDrawing(e.latlng);
                }
            }
        }

        function onMouseMove(e) {
            if (drawMode && isDrawing && drawStartPoint) {
                updateDrawPreview(e.latlng);
            }
        }

        function startDrawing(latlng) {
            isDrawing = true;
            drawStartPoint = latlng;
        }

        function updateDrawPreview(latlng) {
            if (previewLayer) {
                map.removeLayer(previewLayer);
            }
            
            if (currentDrawMode === 'rectangle') {
                previewLayer = L.rectangle([drawStartPoint, latlng], {
                    color: currentColor,
                    weight: 1,
                    fillOpacity: 0.1,
                    dashArray: '5, 5'
                });
            } else if (currentDrawMode === 'circle') {
                const radius = map.distance(drawStartPoint, latlng);
                previewLayer = L.circle(drawStartPoint, {
                    radius: radius,
                    color: currentColor,
                    weight: 1,
                    fillOpacity: 0.1,
                    dashArray: '5, 5'
                });
            }
            
            if (previewLayer) {
                map.addLayer(previewLayer);
            }
        }

        function finishDrawing(latlng) {
            if (previewLayer) {
                map.removeLayer(previewLayer);
                previewLayer = null;
            }
            
            const obstacleId = 'obs_' + Date.now();
            let obstacleData = {
                type: currentDrawMode,
                color: currentColor,
                createdBy: playerName,
                timestamp: Date.now()
            };
            
            let finalLayer;
            
            if (currentDrawMode === 'rectangle') {
                const bounds = L.latLngBounds(drawStartPoint, latlng);
                obstacleData.bounds = {
                    north: bounds.getNorth(),
                    south: bounds.getSouth(),
                    east: bounds.getEast(),
                    west: bounds.getWest()
                };
                
                finalLayer = L.rectangle(bounds, {
                    color: currentColor,
                    weight: 2,
                    fillOpacity: 0.3,
                    interactive: !enemyMode  // D√©sactiver interaction si mode ennemi
                });
            } else if (currentDrawMode === 'circle') {
                const radius = map.distance(drawStartPoint, latlng);
                obstacleData.center = {lat: drawStartPoint.lat, lng: drawStartPoint.lng};
                obstacleData.radius = radius;
                
                finalLayer = L.circle(drawStartPoint, {
                    radius: radius,
                    color: currentColor,
                    weight: 2,
                    fillOpacity: 0.3,
                    interactive: !enemyMode  // D√©sactiver interaction si mode ennemi
                });
            }
            
            if (finalLayer) {
                finalLayer._obstacleId = obstacleId;
                finalLayer.bindPopup(`
                    <b>${currentDrawMode}</b><br>
                    Par: ${playerName}<br>
                    <button onclick="removeObstacle('${obstacleId}')" style="background: #ff4444; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer;">
                        Supprimer
                    </button>
                `);
                obstacleGroup.addLayer(finalLayer);
                
                if (database && isConnected) {
                    const obsRef = ref(database, `obstacles/${teamCode}/${obstacleId}`);
                    set(obsRef, obstacleData);
                }
                
                notify('Obstacle cr√©√©');
            }
            
            cancelDrawing();
        }

        function cancelDrawing() {
            if (previewLayer) {
                map.removeLayer(previewLayer);
                previewLayer = null;
            }
            isDrawing = false;
            drawStartPoint = null;
        }

        function addEnemyMarker(latlng) {
            const enemyId = 'enemy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            const enemyData = {
                lat: latlng.lat,
                lng: latlng.lng,
                reportedBy: playerName,
                timestamp: Date.now(),
                expiresAt: Date.now() + 30000 // Expire dans 30 secondes
            };
            
            console.log('Cr√©ation ennemi:', enemyId, enemyData);
            
            // Sauvegarder dans Firebase pour partage avec l'√©quipe
            if (database && isConnected && teamCode) {
                const enemyNodeRef = ref(database, `enemies/${teamCode}/${enemyId}`);
                set(enemyNodeRef, enemyData)
                    .then(() => {
                        console.log('Ennemi partag√© dans Firebase');
                    })
                    .catch(error => {
                        console.error('Erreur partage ennemi:', error);
                        notify('Erreur partage ennemi');
                    });
            } else {
                console.warn('Pas de connexion Firebase ou pas d\'√©quipe');
                // Cr√©er quand m√™me localement
                createEnemyMarker(enemyId, enemyData);
            }
            
            notify('üéØ Ennemi marqu√© (30s)');
            if (navigator.vibrate) navigator.vibrate(200);
        }
        
        function createEnemyMarker(id, data) {
            // Ne pas recr√©er si existe d√©j√†
            if (enemyMarkers[id]) {
                console.log('Marqueur ennemi existe d√©j√†:', id);
                return;
            }
            
            console.log('Cr√©ation marqueur ennemi:', id, data);
            
            const icon = L.divIcon({
                className: '',
                html: `<div style="width: 24px; height: 24px; background: #ff0000; border: 3px solid #ffff00; border-radius: 50%; box-shadow: 0 0 20px #ff0000; animation: enemyPulse 1s infinite; position: relative;">
                    <div style="position: absolute; top: -22px; left: 50%; transform: translateX(-50%); background: #ff0000; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: bold; white-space: nowrap; border: 1px solid #ffff00;">
                        ‚ö†Ô∏è ${data.reportedBy || 'ENNEMI'}
                    </div>
                </div>
                <style>
                    @keyframes enemyPulse { 
                        0%, 100% { opacity: 1; transform: scale(1); } 
                        50% { opacity: 0.8; transform: scale(1.2); } 
                    }
                </style>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            
            const marker = L.marker([data.lat, data.lng], {
                icon: icon,
                zIndexOffset: 3000 // Tr√®s haut pour √™tre au-dessus de tout
            }).addTo(map);
            
            const timeRemaining = Math.max(0, Math.round((data.expiresAt - Date.now()) / 1000));
            marker.bindPopup(`
                <b>‚ö†Ô∏è ENNEMI D√âTECT√â</b><br>
                Signal√© par: <b>${data.reportedBy}</b><br>
                Expire dans: <b>${timeRemaining}s</b>
            `);
            
            enemyMarkers[id] = marker;
            
            // Auto-suppression apr√®s expiration
            const timeUntilExpiry = data.expiresAt - Date.now();
            if (timeUntilExpiry > 0) {
                setTimeout(() => {
                    if (enemyMarkers[id]) {
                        console.log('Suppression auto ennemi:', id);
                        map.removeLayer(enemyMarkers[id]);
                        delete enemyMarkers[id];
                        
                        // Supprimer de Firebase aussi
                        if (database && isConnected && teamCode) {
                            const enemyNodeRef = ref(database, `enemies/${teamCode}/${id}`);
                            remove(enemyNodeRef).catch(err => console.error('Erreur suppression Firebase:', err));
                        }
                    }
                }, timeUntilExpiry);
            } else {
                console.log('Ennemi d√©j√† expir√©:', id);
            }
        }
        
        function updateEnemies(snapshot) {
            const data = snapshot.val();
            console.log('Mise √† jour ennemis Firebase:', data);
            
            // Supprimer les marqueurs qui n'existent plus dans Firebase
            Object.keys(enemyMarkers).forEach(id => {
                if (!data || !data[id]) {
                    console.log('Suppression ennemi local:', id);
                    if (map.hasLayer(enemyMarkers[id])) {
                        map.removeLayer(enemyMarkers[id]);
                    }
                    delete enemyMarkers[id];
                }
            });
            
            if (!data) return;
            
            // Ajouter/mettre √† jour les marqueurs depuis Firebase
            Object.keys(data).forEach(id => {
                const enemy = data[id];
                
                // V√©rifier si l'ennemi n'a pas expir√©
                if (enemy.expiresAt && Date.now() > enemy.expiresAt) {
                    console.log('Ennemi expir√© dans Firebase:', id);
                    // Supprimer de Firebase si expir√©
                    const enemyNodeRef = ref(database, `enemies/${teamCode}/${id}`);
                    remove(enemyNodeRef);
                    return;
                }
                
                // Cr√©er le marqueur s'il n'existe pas d√©j√†
                if (!enemyMarkers[id]) {
                    console.log('Nouvel ennemi depuis Firebase:', id);
                    createEnemyMarker(id, enemy);
                    
                    // Notification si c'est un ennemi signal√© par un autre
                    if (enemy.reportedBy && enemy.reportedBy !== playerName) {
                        notify(`‚ö†Ô∏è ${enemy.reportedBy} signale un ennemi !`);
                        if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
                    }
                }
            });
        }

        function removeObstacle(id) {
            if (database && isConnected) {
                const obsRef = ref(database, `obstacles/${teamCode}/${id}`);
                remove(obsRef);
            }
            
            obstacleGroup.eachLayer(layer => {
                if (layer._obstacleId === id) {
                    obstacleGroup.removeLayer(layer);
                }
            });
            
            notify('Obstacle supprim√©');
        }

        function showSetup() {
            // Si on est d√©j√† connect√© avec une √©quipe, montrer le QR code
            if (teamCode && playerName) {
                showQRCode();
            } else {
                // Sinon, montrer l'√©cran de configuration
                document.getElementById('setupScreen').classList.remove('hidden');
                document.getElementById('map').classList.add('hidden');
                document.getElementById('gameHUD').classList.add('hidden');
            }
        }

        function updateLoading(text) {
            document.getElementById('loadingStatus').textContent = text;
        }

        function updateStatus(id, text) {
            const element = document.getElementById(id);
            if (element) element.textContent = text;
        }

        function notify(message) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            document.body.appendChild(notif);
            
            setTimeout(() => {
                if (document.body.contains(notif)) {
                    notif.remove();
                }
            }, 3000);
        }

        // Charger config sauvegard√©e et g√©rer les liens partag√©s
        window.addEventListener('load', () => {
            // V√©rifier s'il y a un param√®tre team dans l'URL (QR code scann√©)
            const urlParams = new URLSearchParams(window.location.search);
            const sharedTeam = urlParams.get('team');
            
            if (sharedTeam) {
                // √âquipe partag√©e d√©tect√©e
                document.getElementById('teamCode').value = sharedTeam.toUpperCase();
                notify(`√âquipe d√©tect√©e : ${sharedTeam.toUpperCase()}`);
                
                // Nettoyer l'URL pour √©viter de garder le param√®tre
                window.history.replaceState({}, document.title, window.location.pathname);
                
                // Mettre le focus sur le champ nom
                document.getElementById('playerName').focus();
            } else {
                // Charger la config sauvegard√©e normalement
                const saved = localStorage.getItem('airsoftConfig');
                if (saved) {
                    const config = JSON.parse(saved);
                    document.getElementById('teamCode').value = config.teamCode || '';
                    document.getElementById('playerName').value = config.playerName || '';
                }
            }
            
            // Enregistrer le Service Worker pour PWA
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js').then(registration => {
                    console.log('Service Worker enregistr√©', registration);
                }).catch(error => {
                    console.log('Service Worker erreur:', error);
                });
            }
        });
        
        // Capturer l'√©v√©nement d'installation PWA
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('Installation PWA disponible');
            
            // Si le modal QR est ouvert, montrer le bouton
            if (document.getElementById('qrModal').style.display === 'flex') {
                document.getElementById('installBtn').style.display = 'inline-block';
            }
        });
        
        // √âv√©nement apr√®s installation
        window.addEventListener('appinstalled', () => {
            console.log('PWA install√©e');
            notify('Application install√©e !');
            deferredPrompt = null;
        });

        // Nettoyage et synchronisation p√©riodique
        window.addEventListener('beforeunload', () => {
            if (watchId) navigator.geolocation.clearWatch(watchId);
            if (database && playerName && teamCode && isConnected) {
                const playerRef = ref(database, `teams/${teamCode}/${playerName}`);
                remove(playerRef);
            }
        });

        // Partage position r√©gulier
        setInterval(() => {
            if (currentPosition && isConnected) {
                sharePosition();
            }
        }, 5000);
        
        // Debug pour les ennemis - v√©rifier la synchronisation
        setInterval(() => {
            if (isConnected && database && teamCode) {
                const enemiesRef = ref(database, `enemies/${teamCode}`);
                onValue(enemiesRef, (snapshot) => {
                    const count = snapshot.val() ? Object.keys(snapshot.val()).length : 0;
                    console.log(`Ennemis dans Firebase: ${count}`);
                }, { onlyOnce: true });
            }
        }, 10000); // Check toutes les 10 secondes

        console.log('üéØ Airsoft Tactical Pro - Version finale');
        console.log('Pour d√©bugger: Ouvrez la console F12');
        console.log('Si les ennemis ne se synchronisent pas, v√©rifiez:');
        console.log('1. Que vous √™tes dans la m√™me √©quipe (m√™me code)');
        console.log('2. Que Firebase est connect√© (statut üî•ON)');
        console.log('3. Les messages dans cette console');
    </script>
</body>
</html>